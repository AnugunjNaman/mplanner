{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MPlanner","text":"<p>A Long Way to Go</p> <p>\ud83d\udea7 This project is a work in progress. We're on our way to making it perfect, but there's still more to do! If you'd like to contribute, check out our Contributing Guide \ud83d\udc9c.</p> <p>MPlanner is a compact, concise, and customizable 3D motion planning library. It is designed to simplify motion planning for everyone\u2014whether you're a researcher, engineer, or enthusiast.</p>"},{"location":"#features","title":"Features","text":"<p>Customizable 3D Motion Planning:</p> <ul> <li>Supports a variety of heuristics for pathfinding (e.g., Euclidean, Manhattan).</li> <li>Handles multi-grid environments for complex navigation scenarios.</li> </ul> <p>Optimized Data Structures:</p> <ul> <li>Priority queue for efficient pathfinding.</li> <li>Flexible grid and node-based representation.</li> </ul> <p>Extensible Framework:</p> <ul> <li>Implement your algorithms by extending the base <code>planner</code> class.</li> <li>Suitable for algorithms like A*, Dijkstra, and custom planners.</li> </ul> <p>Pythonic and User-Friendly:</p> <ul> <li>Designed for developers and learners alike.</li> <li>Integrates seamlessly with Python 3.10+.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install MPlanner using Poetry:</p> <pre><code>git clone https://github.com/AnugunjNaman/mplanner.git\ncd mplanner\npoetry install\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Head over to the Example guide for step-by-step example instructions on using MPlanner.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions from the community!  </p> <ul> <li>Please use GitHub Flow:  </li> <li>Create a branch,  </li> <li>Add your commits,  </li> <li>Open a pull request.</li> </ul> <p>For more details, check out our Contributing Guide. It includes information on our Code of Conduct and the process for submitting pull requests.</p>"},{"location":"#license","title":"License","text":"<p>MPlanner is open source and available under the MIT License. See the LICENSE file for details.</p>"},{"location":"algorithms/","title":"Algorithms","text":"<p>We currently support onlt two algorithms:</p> <ul> <li>A* Algorithm</li> <li>Dijkstra Algorithm</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome contributions from the community!  </p> <ul> <li>Please use GitHub Flow:  </li> <li>Create a branch,  </li> <li>Add your commits,  </li> <li>Open a pull request.</li> </ul>"},{"location":"examples/astar/","title":"Example","text":"<pre><code># Import necessary libraries\nimport numpy as np\nfrom mplanner.core.environment import DMove, Grid\nfrom mplanner.algorithms.astar import AStar\nfrom mplanner.core.utils import mark_obstacles, calculate_grid_size, to_grid_coords\n</code></pre> <pre><code># Configuration Parameters\nresolution = 0.8  # Grid cell size in meters\nenvironment_bounds = {\n    \"min\": (-5, 0, -5),  # Minimum bounds of the environment in Unity coordinates\n    \"max\": (5, 5, 5),    # Maximum bounds of the environment in Unity coordinates\n}\norigin = environment_bounds[\"min\"]  # Origin set as the minimum bounds\n\n# Calculate the grid size automatically based on the environment bounds and resolution\ngrid_size = calculate_grid_size(environment_bounds, resolution)\n\n# Initialize the grid matrix with 1s (walkable areas)\nmatrix = np.ones(grid_size, dtype=np.int8)\n\n# Define obstacles in the environment\n# Each obstacle is defined by its center position and dimensions in Unity coordinates\nobstacles = [\n    ((1.63, 1.82, 1.59), (1.00, 1.00, 1.00)),  # Cube_1\n    ((-1.31, 1.85, -1.82), (1.00, 1.00, 1.00)),  # Cube_2\n]\n</code></pre> <pre><code># Mark the obstacles in the grid\nfor position, dimensions in obstacles:\n    mark_obstacles(matrix, position, dimensions, resolution, origin)\n</code></pre> <pre><code># Create the grid object\ngrid = Grid(matrix=matrix)\n\n# Define the start and end positions in Unity coordinates\nstart_position = (2.16, 2.24, -2.88)  # Start position\nend_position = (-1.05, 1.96, 3.09)    # End position\n\n# Convert the start and end positions to grid coordinates\nstart_coords = to_grid_coords(start_position, resolution, origin)\nend_coords = to_grid_coords(end_position, resolution, origin)\n\n# Create start and end nodes in the grid\nstart = grid.node(*start_coords)\nend = grid.node(*end_coords)\n</code></pre> <pre><code># Initialize the A* path planner\nplanner = AStar(diagonal_movement=DMove.NEVER)\n\n# Run the A* algorithm to compute the path\npath, runs = planner.get_planned_path(start, end, grid)\n</code></pre> <pre><code># Convert the path back to Unity world coordinates\nwaypoints = [\n    ((origin[0] + p.x * resolution).__round__(2), (origin[1] + p.y * resolution).__round__(2), (origin[2] + p.z * resolution).__round__(2))\n    for p in path\n]\n\nprint(\"Operations:\", runs, \"Path Length:\", len(path))\nprint(\"List of waypoints\")\nfor p in waypoints:\n    print(p)\n</code></pre> <pre>\n<code>Operations: 0 Path Length: 13\nList of waypoints\n(2.2, 2.4, -2.6)\n(2.2, 1.6, -2.6)\n(1.4, 1.6, -2.6)\n(0.6, 1.6, -2.6)\n(-0.2, 1.6, -2.6)\n(-0.2, 1.6, -1.8)\n(-0.2, 1.6, -1.0)\n(-1.0, 1.6, -1.0)\n(-1.0, 1.6, -0.2)\n(-1.0, 1.6, 0.6)\n(-1.0, 1.6, 1.4)\n(-1.0, 1.6, 2.2)\n(-1.0, 1.6, 3.0)\n</code>\n</pre>"},{"location":"examples/astar/#a-path-planning-in-a-grid-environment-with-obstacles","title":"A* Path Planning in a Grid Environment with Obstacles","text":"<p>This notebook demonstrates how to use the <code>AStar</code> algorithm for path planning in a 3D grid environment with obstacles. The environment, start and goal points, and obstacles are defined in Unity world coordinates, and a grid resolution is used to map the environment into a grid.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>mplanner<ul> <li>algorithms<ul> <li>astar</li> <li>dijkstra</li> </ul> </li> <li>core<ul> <li>distance</li> <li>environment</li> <li>planner</li> <li>priority_queue</li> <li>utils</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/algorithms/astar/","title":"astar","text":""},{"location":"reference/algorithms/astar/#mplanner.algorithms.astar.AStar","title":"<code>AStar</code>","text":"<p>               Bases: <code>Planner</code></p> <p>A* Algorithm for 3D Pathfinding.</p> <p>This class implements a 3D version of the A* algorithm. It calculates the shortest path between a start and target node while considering movement costs and optional diagonal movement.</p> <p>Attributes:</p> Name Type Description <code>heuristic</code> <code>Callable</code> <p>Function to estimate the cost to the target node.</p> <code>weight</code> <code>int</code> <p>Weight factor for the cost of moving between nodes.</p> <code>diagonal_movement</code> <code>int</code> <p>Defines if and how diagonal movement is allowed.</p> <code>time_limit</code> <code>float</code> <p>Maximum time (in seconds) before the search aborts.</p> <code>max_runs</code> <code>Union[int, float]</code> <p>Maximum allowable iterations before termination.</p> Source code in <code>mplanner/algorithms/astar.py</code> <pre><code>class AStar(Planner):\n    \"\"\"\n    A* Algorithm for 3D Pathfinding.\n\n    This class implements a 3D version of the A* algorithm. It calculates the shortest path\n    between a start and target node while considering movement costs and optional diagonal movement.\n\n    Attributes:\n        heuristic (Callable): Function to estimate the cost to the target node.\n        weight (int): Weight factor for the cost of moving between nodes.\n        diagonal_movement (int): Defines if and how diagonal movement is allowed.\n        time_limit (float): Maximum time (in seconds) before the search aborts.\n        max_runs (Union[int, float]): Maximum allowable iterations before termination.\n    \"\"\"\n    def __init__(\n        self,\n        heuristic: Optional[Callable] = None,\n        weight: int = 1,\n        diagonal_movement: int = DMove.NEVER,\n        time_limit: float = float(\"inf\"),\n        max_runs: Union[int, float] = float(\"inf\"),\n    ):\n        super().__init__(\n            heuristic=heuristic or manhattan,\n            weight=weight,\n            diagonal_movement=diagonal_movement,\n            time_limit=time_limit,\n            max_runs=max_runs,\n        )\n        # Default heuristic assignment\n        if not self.heuristic:\n            self.heuristic = manhattan if diagonal_movement == DMove.NEVER else octile\n\n    def explore_neighbors(\n        self,\n        current_node: GridNode,\n        target_node: GridNode,\n        grid: Grid,\n        open_list: List,\n    ) -&gt; Optional[List[GridNode]]:\n        \"\"\"\n        Explore and process neighboring nodes for the current node.\n\n        Args:\n            current_node (GridNode): The node currently being processed.\n            target_node (GridNode): The destination node.\n            grid (Grid): The grid representing the search space.\n            open_list (List): The priority queue containing nodes to be evaluated.\n\n        Returns:\n            Optional[List[GridNode]]: The path as a list of nodes if the target is reached, otherwise None.\n        \"\"\"\n        # Retrieve valid neighbors\n        neighbors = self.get_neighboring_nodes(grid, current_node)\n\n        for neighbor in neighbors:\n            if neighbor.closed:\n                continue  # Skip nodes already processed\n\n            # Compute cost from current node to neighbor\n            tentative_g_cost = current_node.g + grid.calc_cost(current_node, neighbor, self.weighted)\n\n            if not neighbor.opened or tentative_g_cost &lt; neighbor.g:\n                # Update costs and parent if a better path is found\n                neighbor.g = tentative_g_cost\n                neighbor.h = self.distance_heuristic(neighbor, target_node)\n                neighbor.f = neighbor.g + neighbor.h\n                neighbor.parent = current_node\n\n                if not neighbor.opened:\n                    open_list.push_node(neighbor)\n                    neighbor.opened = True\n\n    def evaluate_neighbors(\n        self,\n        start_node: GridNode,\n        target_node: GridNode,\n        grid: Grid,\n        open_list: List,\n    ) -&gt; Optional[List[GridNode]]:\n        \"\"\"\n        Process the node with the lowest cost (f) and evaluate its neighbors.\n\n        Args:\n            start_node (GridNode): The start node of the pathfinding process.\n            target_node (GridNode): The target (goal) node.\n            grid (Grid): The grid representing the search space.\n            open_list (List): The priority queue containing nodes to be evaluated.\n\n        Returns:\n            Optional[List[GridNode]]: A path to the target node if found, otherwise None.\n        \"\"\"\n        current_node = open_list.pop_node()\n        current_node.closed = True\n\n        if current_node == target_node:\n            # Path found\n            return backtrack(current_node)\n\n        self.explore_neighbors(current_node, target_node, grid, open_list)\n        return None\n\n    def get_planned_path(\n        self, start_node: GridNode, target_node: GridNode, grid: Grid\n    ) -&gt; Tuple[List[GridNode], int]:\n        \"\"\"\n        Executes the A* search to find a path from start to target.\n\n        Args:\n            start_node (GridNode): Starting node of the path.\n            target_node (GridNode): Destination node of the path.\n            grid (Grid): The 3D grid representing the search space.\n\n        Returns:\n            Tuple[List[GridNode], int]: Path as a list of nodes and the number of iterations performed.\n        \"\"\"\n        # Initialize costs and open list\n        start_node.g = 0\n        start_node.f = 0\n        start_node.h = self.distance_heuristic(start_node, target_node)\n        start_node.opened = True\n\n        open_list = self.create_open_list(grid, start_node)\n\n        while len(open_list) &gt; 0:\n            self.keep_running()\n            path = self.evaluate_neighbors(start_node, target_node, grid, open_list)\n            if path:\n                return path, self.runs\n\n        # No path found\n        return [], self.runs\n\n    def create_open_list(self, grid: Grid, start_node: GridNode) -&gt; PriorityQueueStructure:\n        \"\"\"\n        Creates and initializes the open list with the starting node.\n\n        Args:\n            grid (Grid): The grid representing the search space.\n            start_node (GridNode): The starting node.\n\n        Returns:\n            PriorityQueueStructure: Initialized priority queue with the start node.\n        \"\"\"\n        return PriorityQueueStructure(start_node, grid)\n\n    def __repr__(self):\n        return (\n            f\"&lt;AStar3D(heuristic={self.heuristic.__name__}, weight={self.weight}, \"\n            f\"diagonal_movement={self.diagonal_movement})&gt;\"\n        )\n</code></pre>"},{"location":"reference/algorithms/astar/#mplanner.algorithms.astar.AStar.create_open_list","title":"<code>create_open_list(grid, start_node)</code>","text":"<p>Creates and initializes the open list with the starting node.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>Grid</code> <p>The grid representing the search space.</p> required <code>start_node</code> <code>GridNode</code> <p>The starting node.</p> required <p>Returns:</p> Name Type Description <code>PriorityQueueStructure</code> <code>PriorityQueueStructure</code> <p>Initialized priority queue with the start node.</p> Source code in <code>mplanner/algorithms/astar.py</code> <pre><code>def create_open_list(self, grid: Grid, start_node: GridNode) -&gt; PriorityQueueStructure:\n    \"\"\"\n    Creates and initializes the open list with the starting node.\n\n    Args:\n        grid (Grid): The grid representing the search space.\n        start_node (GridNode): The starting node.\n\n    Returns:\n        PriorityQueueStructure: Initialized priority queue with the start node.\n    \"\"\"\n    return PriorityQueueStructure(start_node, grid)\n</code></pre>"},{"location":"reference/algorithms/astar/#mplanner.algorithms.astar.AStar.evaluate_neighbors","title":"<code>evaluate_neighbors(start_node, target_node, grid, open_list)</code>","text":"<p>Process the node with the lowest cost (f) and evaluate its neighbors.</p> <p>Parameters:</p> Name Type Description Default <code>start_node</code> <code>GridNode</code> <p>The start node of the pathfinding process.</p> required <code>target_node</code> <code>GridNode</code> <p>The target (goal) node.</p> required <code>grid</code> <code>Grid</code> <p>The grid representing the search space.</p> required <code>open_list</code> <code>List</code> <p>The priority queue containing nodes to be evaluated.</p> required <p>Returns:</p> Type Description <code>Optional[List[GridNode]]</code> <p>Optional[List[GridNode]]: A path to the target node if found, otherwise None.</p> Source code in <code>mplanner/algorithms/astar.py</code> <pre><code>def evaluate_neighbors(\n    self,\n    start_node: GridNode,\n    target_node: GridNode,\n    grid: Grid,\n    open_list: List,\n) -&gt; Optional[List[GridNode]]:\n    \"\"\"\n    Process the node with the lowest cost (f) and evaluate its neighbors.\n\n    Args:\n        start_node (GridNode): The start node of the pathfinding process.\n        target_node (GridNode): The target (goal) node.\n        grid (Grid): The grid representing the search space.\n        open_list (List): The priority queue containing nodes to be evaluated.\n\n    Returns:\n        Optional[List[GridNode]]: A path to the target node if found, otherwise None.\n    \"\"\"\n    current_node = open_list.pop_node()\n    current_node.closed = True\n\n    if current_node == target_node:\n        # Path found\n        return backtrack(current_node)\n\n    self.explore_neighbors(current_node, target_node, grid, open_list)\n    return None\n</code></pre>"},{"location":"reference/algorithms/astar/#mplanner.algorithms.astar.AStar.explore_neighbors","title":"<code>explore_neighbors(current_node, target_node, grid, open_list)</code>","text":"<p>Explore and process neighboring nodes for the current node.</p> <p>Parameters:</p> Name Type Description Default <code>current_node</code> <code>GridNode</code> <p>The node currently being processed.</p> required <code>target_node</code> <code>GridNode</code> <p>The destination node.</p> required <code>grid</code> <code>Grid</code> <p>The grid representing the search space.</p> required <code>open_list</code> <code>List</code> <p>The priority queue containing nodes to be evaluated.</p> required <p>Returns:</p> Type Description <code>Optional[List[GridNode]]</code> <p>Optional[List[GridNode]]: The path as a list of nodes if the target is reached, otherwise None.</p> Source code in <code>mplanner/algorithms/astar.py</code> <pre><code>def explore_neighbors(\n    self,\n    current_node: GridNode,\n    target_node: GridNode,\n    grid: Grid,\n    open_list: List,\n) -&gt; Optional[List[GridNode]]:\n    \"\"\"\n    Explore and process neighboring nodes for the current node.\n\n    Args:\n        current_node (GridNode): The node currently being processed.\n        target_node (GridNode): The destination node.\n        grid (Grid): The grid representing the search space.\n        open_list (List): The priority queue containing nodes to be evaluated.\n\n    Returns:\n        Optional[List[GridNode]]: The path as a list of nodes if the target is reached, otherwise None.\n    \"\"\"\n    # Retrieve valid neighbors\n    neighbors = self.get_neighboring_nodes(grid, current_node)\n\n    for neighbor in neighbors:\n        if neighbor.closed:\n            continue  # Skip nodes already processed\n\n        # Compute cost from current node to neighbor\n        tentative_g_cost = current_node.g + grid.calc_cost(current_node, neighbor, self.weighted)\n\n        if not neighbor.opened or tentative_g_cost &lt; neighbor.g:\n            # Update costs and parent if a better path is found\n            neighbor.g = tentative_g_cost\n            neighbor.h = self.distance_heuristic(neighbor, target_node)\n            neighbor.f = neighbor.g + neighbor.h\n            neighbor.parent = current_node\n\n            if not neighbor.opened:\n                open_list.push_node(neighbor)\n                neighbor.opened = True\n</code></pre>"},{"location":"reference/algorithms/astar/#mplanner.algorithms.astar.AStar.get_planned_path","title":"<code>get_planned_path(start_node, target_node, grid)</code>","text":"<p>Executes the A* search to find a path from start to target.</p> <p>Parameters:</p> Name Type Description Default <code>start_node</code> <code>GridNode</code> <p>Starting node of the path.</p> required <code>target_node</code> <code>GridNode</code> <p>Destination node of the path.</p> required <code>grid</code> <code>Grid</code> <p>The 3D grid representing the search space.</p> required <p>Returns:</p> Type Description <code>Tuple[List[GridNode], int]</code> <p>Tuple[List[GridNode], int]: Path as a list of nodes and the number of iterations performed.</p> Source code in <code>mplanner/algorithms/astar.py</code> <pre><code>def get_planned_path(\n    self, start_node: GridNode, target_node: GridNode, grid: Grid\n) -&gt; Tuple[List[GridNode], int]:\n    \"\"\"\n    Executes the A* search to find a path from start to target.\n\n    Args:\n        start_node (GridNode): Starting node of the path.\n        target_node (GridNode): Destination node of the path.\n        grid (Grid): The 3D grid representing the search space.\n\n    Returns:\n        Tuple[List[GridNode], int]: Path as a list of nodes and the number of iterations performed.\n    \"\"\"\n    # Initialize costs and open list\n    start_node.g = 0\n    start_node.f = 0\n    start_node.h = self.distance_heuristic(start_node, target_node)\n    start_node.opened = True\n\n    open_list = self.create_open_list(grid, start_node)\n\n    while len(open_list) &gt; 0:\n        self.keep_running()\n        path = self.evaluate_neighbors(start_node, target_node, grid, open_list)\n        if path:\n            return path, self.runs\n\n    # No path found\n    return [], self.runs\n</code></pre>"},{"location":"reference/algorithms/dijkstra/","title":"dijkstra","text":""},{"location":"reference/algorithms/dijkstra/#mplanner.algorithms.dijkstra.Dijkstra3D","title":"<code>Dijkstra3D</code>","text":"<p>               Bases: <code>Planner</code></p> <p>Dijkstra's Algorithm for 3D Pathfinding.</p> <p>This class implements Dijkstra's algorithm, which finds the shortest path from a start node to a target node in a 3D grid. Dijkstra's algorithm does not use a heuristic function.</p> <p>Attributes:</p> Name Type Description <code>weight</code> <code>int</code> <p>Weight factor for the cost of moving between nodes.</p> <code>diagonal_movement</code> <code>int</code> <p>Defines if and how diagonal movement is allowed.</p> <code>time_limit</code> <code>float</code> <p>Maximum time (in seconds) before the search aborts.</p> <code>max_runs</code> <code>int</code> <p>Maximum allowable iterations before termination.</p> Source code in <code>mplanner/algorithms/dijkstra.py</code> <pre><code>class Dijkstra3D(Planner):\n    \"\"\"\n    Dijkstra's Algorithm for 3D Pathfinding.\n\n    This class implements Dijkstra's algorithm, which finds the shortest path from a start node\n    to a target node in a 3D grid. Dijkstra's algorithm does not use a heuristic function.\n\n    Attributes:\n        weight (int): Weight factor for the cost of moving between nodes.\n        diagonal_movement (int): Defines if and how diagonal movement is allowed.\n        time_limit (float): Maximum time (in seconds) before the search aborts.\n        max_runs (int): Maximum allowable iterations before termination.\n    \"\"\"\n    def __init__(\n        self,\n        weight: int = 1,\n        diagonal_movement: int = 0,\n        time_limit: float = float(\"inf\"),\n        max_runs: int = float(\"inf\"),\n    ):\n        super().__init__(\n            heuristic=None,  # No heuristic for Dijkstra's algorithm\n            weight=weight,\n            diagonal_movement=diagonal_movement,\n            time_limit=time_limit,\n            max_runs=max_runs,\n        )\n\n    def explore_neighbors(\n        self,\n        current_node: GridNode,\n        grid: Grid,\n        open_list: List,\n    ):\n        \"\"\"\n        Explore and process neighbors of the current node during Dijkstra's search.\n\n        Args:\n            current_node (GridNode): The node currently being processed.\n            grid (Grid): The grid representing the search space.\n            open_list (List): The priority queue containing nodes to be evaluated.\n        \"\"\"\n        neighbors = self.get_neighboring_nodes(grid, current_node)\n\n        for neighbor in neighbors:\n            if neighbor.closed:\n                continue  # Skip nodes already processed\n\n            # Compute cost to reach the neighbor\n            tentative_g_cost = current_node.g + grid.calc_cost(current_node, neighbor, self.weighted)\n\n            if not neighbor.opened or tentative_g_cost &lt; neighbor.g:\n                # Update costs and parent if a better path is found\n                neighbor.g = tentative_g_cost\n                neighbor.f = tentative_g_cost  # For Dijkstra's, f is equivalent to g\n                neighbor.parent = current_node\n\n                if not neighbor.opened:\n                    open_list.push_node(neighbor)\n                    neighbor.opened = True\n\n    def evaluate_neighbors(\n        self,\n        start_node: GridNode,\n        target_node: GridNode,\n        grid: Grid,\n        open_list: List,\n    ) -&gt; List[GridNode]:\n        \"\"\"\n        Process the node with the lowest cost (f) and evaluate its neighbors.\n\n        Args:\n            start_node (GridNode): The starting node of the search.\n            target_node (GridNode): The target node.\n            grid (Grid): The grid representing the search space.\n            open_list (List): The priority queue of nodes to evaluate.\n\n        Returns:\n            List[GridNode]: A path to the target node if found, otherwise None.\n        \"\"\"\n        current_node = open_list.pop_node()\n        current_node.closed = True\n\n        if current_node == target_node:\n            # Path found\n            return backtrack(current_node)\n\n        # Explore and process neighbors\n        self.explore_neighbors(current_node, grid, open_list)\n        return None\n\n    def get_planned_path(\n        self, start_node: GridNode, target_node: GridNode, grid: Grid\n    ) -&gt; Tuple[List[GridNode], int]:\n        \"\"\"\n        Executes Dijkstra's algorithm to find the shortest path.\n\n        Args:\n            start_node (GridNode): The starting node.\n            target_node (GridNode): The destination node.\n            grid (Grid): The grid representing the search space.\n\n        Returns:\n            Tuple[List[GridNode], int]: The path as a list of nodes and the number of iterations performed.\n        \"\"\"\n        # Initialize costs and open list\n        start_node.g = 0\n        start_node.f = 0  # f = g for Dijkstra's\n        start_node.opened = True\n\n        open_list = self.create_open_list(grid, start_node)\n\n        while len(open_list) &gt; 0:\n            self.keep_running()\n            path = self.evaluate_neighbors(start_node, target_node, grid, open_list)\n            if path:\n                return path, self.runs\n\n        # No path found\n        return [], self.runs\n\n    def create_open_list(self, grid: Grid, start_node: GridNode) -&gt; PriorityQueueStructure:\n        \"\"\"\n        Creates and initializes the open list with the starting node.\n\n        Args:\n            grid (Grid): The grid representing the search space.\n            start_node (GridNode): The starting node.\n\n        Returns:\n            PriorityQueueStructure: Initialized priority queue with the start node.\n        \"\"\"\n        return PriorityQueueStructure(start_node, grid)\n\n    def __repr__(self):\n        return (\n            f\"&lt;Dijkstra3D(weight={self.weight}, diagonal_movement={self.diagonal_movement})&gt;\"\n        )\n</code></pre>"},{"location":"reference/algorithms/dijkstra/#mplanner.algorithms.dijkstra.Dijkstra3D.create_open_list","title":"<code>create_open_list(grid, start_node)</code>","text":"<p>Creates and initializes the open list with the starting node.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>Grid</code> <p>The grid representing the search space.</p> required <code>start_node</code> <code>GridNode</code> <p>The starting node.</p> required <p>Returns:</p> Name Type Description <code>PriorityQueueStructure</code> <code>PriorityQueueStructure</code> <p>Initialized priority queue with the start node.</p> Source code in <code>mplanner/algorithms/dijkstra.py</code> <pre><code>def create_open_list(self, grid: Grid, start_node: GridNode) -&gt; PriorityQueueStructure:\n    \"\"\"\n    Creates and initializes the open list with the starting node.\n\n    Args:\n        grid (Grid): The grid representing the search space.\n        start_node (GridNode): The starting node.\n\n    Returns:\n        PriorityQueueStructure: Initialized priority queue with the start node.\n    \"\"\"\n    return PriorityQueueStructure(start_node, grid)\n</code></pre>"},{"location":"reference/algorithms/dijkstra/#mplanner.algorithms.dijkstra.Dijkstra3D.evaluate_neighbors","title":"<code>evaluate_neighbors(start_node, target_node, grid, open_list)</code>","text":"<p>Process the node with the lowest cost (f) and evaluate its neighbors.</p> <p>Parameters:</p> Name Type Description Default <code>start_node</code> <code>GridNode</code> <p>The starting node of the search.</p> required <code>target_node</code> <code>GridNode</code> <p>The target node.</p> required <code>grid</code> <code>Grid</code> <p>The grid representing the search space.</p> required <code>open_list</code> <code>List</code> <p>The priority queue of nodes to evaluate.</p> required <p>Returns:</p> Type Description <code>List[GridNode]</code> <p>List[GridNode]: A path to the target node if found, otherwise None.</p> Source code in <code>mplanner/algorithms/dijkstra.py</code> <pre><code>def evaluate_neighbors(\n    self,\n    start_node: GridNode,\n    target_node: GridNode,\n    grid: Grid,\n    open_list: List,\n) -&gt; List[GridNode]:\n    \"\"\"\n    Process the node with the lowest cost (f) and evaluate its neighbors.\n\n    Args:\n        start_node (GridNode): The starting node of the search.\n        target_node (GridNode): The target node.\n        grid (Grid): The grid representing the search space.\n        open_list (List): The priority queue of nodes to evaluate.\n\n    Returns:\n        List[GridNode]: A path to the target node if found, otherwise None.\n    \"\"\"\n    current_node = open_list.pop_node()\n    current_node.closed = True\n\n    if current_node == target_node:\n        # Path found\n        return backtrack(current_node)\n\n    # Explore and process neighbors\n    self.explore_neighbors(current_node, grid, open_list)\n    return None\n</code></pre>"},{"location":"reference/algorithms/dijkstra/#mplanner.algorithms.dijkstra.Dijkstra3D.explore_neighbors","title":"<code>explore_neighbors(current_node, grid, open_list)</code>","text":"<p>Explore and process neighbors of the current node during Dijkstra's search.</p> <p>Parameters:</p> Name Type Description Default <code>current_node</code> <code>GridNode</code> <p>The node currently being processed.</p> required <code>grid</code> <code>Grid</code> <p>The grid representing the search space.</p> required <code>open_list</code> <code>List</code> <p>The priority queue containing nodes to be evaluated.</p> required Source code in <code>mplanner/algorithms/dijkstra.py</code> <pre><code>def explore_neighbors(\n    self,\n    current_node: GridNode,\n    grid: Grid,\n    open_list: List,\n):\n    \"\"\"\n    Explore and process neighbors of the current node during Dijkstra's search.\n\n    Args:\n        current_node (GridNode): The node currently being processed.\n        grid (Grid): The grid representing the search space.\n        open_list (List): The priority queue containing nodes to be evaluated.\n    \"\"\"\n    neighbors = self.get_neighboring_nodes(grid, current_node)\n\n    for neighbor in neighbors:\n        if neighbor.closed:\n            continue  # Skip nodes already processed\n\n        # Compute cost to reach the neighbor\n        tentative_g_cost = current_node.g + grid.calc_cost(current_node, neighbor, self.weighted)\n\n        if not neighbor.opened or tentative_g_cost &lt; neighbor.g:\n            # Update costs and parent if a better path is found\n            neighbor.g = tentative_g_cost\n            neighbor.f = tentative_g_cost  # For Dijkstra's, f is equivalent to g\n            neighbor.parent = current_node\n\n            if not neighbor.opened:\n                open_list.push_node(neighbor)\n                neighbor.opened = True\n</code></pre>"},{"location":"reference/algorithms/dijkstra/#mplanner.algorithms.dijkstra.Dijkstra3D.get_planned_path","title":"<code>get_planned_path(start_node, target_node, grid)</code>","text":"<p>Executes Dijkstra's algorithm to find the shortest path.</p> <p>Parameters:</p> Name Type Description Default <code>start_node</code> <code>GridNode</code> <p>The starting node.</p> required <code>target_node</code> <code>GridNode</code> <p>The destination node.</p> required <code>grid</code> <code>Grid</code> <p>The grid representing the search space.</p> required <p>Returns:</p> Type Description <code>Tuple[List[GridNode], int]</code> <p>Tuple[List[GridNode], int]: The path as a list of nodes and the number of iterations performed.</p> Source code in <code>mplanner/algorithms/dijkstra.py</code> <pre><code>def get_planned_path(\n    self, start_node: GridNode, target_node: GridNode, grid: Grid\n) -&gt; Tuple[List[GridNode], int]:\n    \"\"\"\n    Executes Dijkstra's algorithm to find the shortest path.\n\n    Args:\n        start_node (GridNode): The starting node.\n        target_node (GridNode): The destination node.\n        grid (Grid): The grid representing the search space.\n\n    Returns:\n        Tuple[List[GridNode], int]: The path as a list of nodes and the number of iterations performed.\n    \"\"\"\n    # Initialize costs and open list\n    start_node.g = 0\n    start_node.f = 0  # f = g for Dijkstra's\n    start_node.opened = True\n\n    open_list = self.create_open_list(grid, start_node)\n\n    while len(open_list) &gt; 0:\n        self.keep_running()\n        path = self.evaluate_neighbors(start_node, target_node, grid, open_list)\n        if path:\n            return path, self.runs\n\n    # No path found\n    return [], self.runs\n</code></pre>"},{"location":"reference/core/distance/","title":"distance","text":""},{"location":"reference/core/distance/#mplanner.core.distance.chebyshev","title":"<code>chebyshev(x, y, z)</code>","text":"<p>Calculates the Chebyshev distance between two points in 3D space.</p> <p>The Chebyshev distance is the maximum absolute difference along any axis:</p> \\[ d = \\max(|x|, |y|, |z|) \\] <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[int, float]</code> <p>Distance along the x-axis.</p> required <code>y</code> <code>Union[int, float]</code> <p>Distance along the y-axis.</p> required <code>z</code> <code>Union[int, float]</code> <p>Distance along the z-axis.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The Chebyshev distance between the points.</p> Source code in <code>mplanner/core/distance.py</code> <pre><code>def chebyshev(x: Union[int, float], y: Union[int, float], z: Union[int, float]) -&gt; float:\n    \"\"\"\n    Calculates the Chebyshev distance between two points in 3D space.\n\n    The Chebyshev distance is the maximum absolute difference along any axis:\n\n    \\\\[ d = \\\\max(|x|, |y|, |z|) \\\\]\n\n    Args:\n        x (Union[int, float]): Distance along the x-axis.\n        y (Union[int, float]): Distance along the y-axis.\n        z (Union[int, float]): Distance along the z-axis.\n\n    Returns:\n        float: The Chebyshev distance between the points.\n    \"\"\"\n    return max(abs(x), abs(y), abs(z))\n</code></pre>"},{"location":"reference/core/distance/#mplanner.core.distance.euclidean","title":"<code>euclidean(x, y, z)</code>","text":"<p>Calculates the Euclidean distance between two points in 3D space.</p> <p>The Euclidean distance is the straight-line distance between two points, given by:</p> \\[ d = \\sqrt{x^2 + y^2 + z^2}  \\] <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[int, float]</code> <p>Distance along the x-axis.</p> required <code>y</code> <code>Union[int, float]</code> <p>Distance along the y-axis.</p> required <code>z</code> <code>Union[int, float]</code> <p>Distance along the z-axis.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The Euclidean distance between the points.</p> Source code in <code>mplanner/core/distance.py</code> <pre><code>def euclidean(x: Union[int, float], y: Union[int, float], z: Union[int, float]) -&gt; float:\n    \"\"\"\n    Calculates the Euclidean distance between two points in 3D space.\n\n    The Euclidean distance is the straight-line distance between two points, given by:\n\n    \\\\[ d = \\\\sqrt{x^2 + y^2 + z^2}  \\\\] \n\n    Args:\n        x (Union[int, float]): Distance along the x-axis.\n        y (Union[int, float]): Distance along the y-axis.\n        z (Union[int, float]): Distance along the z-axis.\n\n    Returns:\n        float: The Euclidean distance between the points.\n    \"\"\"\n    return math.sqrt(x ** 2 + y ** 2 + z ** 2)\n</code></pre>"},{"location":"reference/core/distance/#mplanner.core.distance.manhattan","title":"<code>manhattan(x, y, z)</code>","text":"<p>Calculates the Manhattan distance between two points in 3D space.</p> <p>The Manhattan distance (or L1 distance) is the sum of the absolute differences along each axis:</p> \\[ d = |x| + |y| + |z| \\] <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[int, float]</code> <p>Distance along the x-axis.</p> required <code>y</code> <code>Union[int, float]</code> <p>Distance along the y-axis.</p> required <code>z</code> <code>Union[int, float]</code> <p>Distance along the z-axis.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The Manhattan distance between the points.</p> Source code in <code>mplanner/core/distance.py</code> <pre><code>def manhattan(x: Union[int, float], y: Union[int, float], z: Union[int, float]) -&gt; float:\n    \"\"\"\n    Calculates the Manhattan distance between two points in 3D space.\n\n    The Manhattan distance (or L1 distance) is the sum of the absolute differences along each axis:\n\n    \\\\[ d = |x| + |y| + |z| \\\\]\n\n    Args:\n        x (Union[int, float]): Distance along the x-axis.\n        y (Union[int, float]): Distance along the y-axis.\n        z (Union[int, float]): Distance along the z-axis.\n\n    Returns:\n        float: The Manhattan distance between the points.\n    \"\"\"\n    return abs(x) + abs(y) + abs(z)\n</code></pre>"},{"location":"reference/core/distance/#mplanner.core.distance.null","title":"<code>null(x, y, z)</code>","text":"<p>Returns 0.0 for any input, representing no distance.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[int, float]</code> <p>Distance along the x-axis.</p> required <code>y</code> <code>Union[int, float]</code> <p>Distance along the y-axis.</p> required <code>z</code> <code>Union[int, float]</code> <p>Distance along the z-axis.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Always returns 0.0, indicating no distance.</p> Source code in <code>mplanner/core/distance.py</code> <pre><code>def null(x: Union[int, float], y: Union[int, float], z: Union[int, float]) -&gt; float:\n    \"\"\"\n    Returns 0.0 for any input, representing no distance.\n\n    Args:\n        x (Union[int, float]): Distance along the x-axis.\n        y (Union[int, float]): Distance along the y-axis.\n        z (Union[int, float]): Distance along the z-axis.\n\n    Returns:\n        float: Always returns 0.0, indicating no distance.\n    \"\"\"\n    return 0.0\n</code></pre>"},{"location":"reference/core/distance/#mplanner.core.distance.octile","title":"<code>octile(x, y, z)</code>","text":"<p>Calculates the generalized octile distance between two points in 3D space.</p> <p>Octile distance is a heuristic metric used in 3D grid-based pathfinding. It combines straight, diagonal (2D), and diagonal (3D) moves with the following weights: - Straight moves: cost = 1 - Diagonal moves in 2D: cost = sqrt(2) - 1  - Diagonal moves in 3D: cost = sqrt(3) - sqrt(2) </p> <p>The formula is as follows:</p> \\[ d = \\text{max_distance} + (\\sqrt{2} - 1) \\cdot \\text{mid_distance} + (\\sqrt{3} - \\sqrt{2}) \\cdot \\text{min_distance} \\] where <ul> <li> \\[ \\text{max_distance} = \\max(|x|, |y|, |z|) \\] </li> <li> \\[ \\text{mid_distance} = \\text{total_distance} - \\text{max_distance} - \\text{min_distance} \\] </li> <li> \\[ \\text{min_distance} = \\min(|x|, |y|, |z|) \\] </li> <li> \\[ \\text{total_distance} = |x| + |y| + |z| \\] </li> </ul> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[int, float]</code> <p>Distance along the x-axis.</p> required <code>y</code> <code>Union[int, float]</code> <p>Distance along the y-axis.</p> required <code>z</code> <code>Union[int, float]</code> <p>Distance along the z-axis.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The generalized octile distance between the points.</p> Source code in <code>mplanner/core/distance.py</code> <pre><code>def octile(x: Union[int, float], y: Union[int, float], z: Union[int, float]) -&gt; float:\n    \"\"\"\n    Calculates the generalized octile distance between two points in 3D space.\n\n    Octile distance is a heuristic metric used in 3D grid-based pathfinding. It combines straight,\n    diagonal (2D), and diagonal (3D) moves with the following weights:\n    - Straight moves: cost = 1\n    - Diagonal moves in 2D: cost = sqrt(2) - 1 \n    - Diagonal moves in 3D: cost = sqrt(3) - sqrt(2) \n\n    The formula is as follows:\n\n    \\\\[ d = \\\\text{max_distance} + (\\\\sqrt{2} - 1) \\\\cdot \\\\text{mid_distance} + (\\\\sqrt{3} - \\\\sqrt{2}) \\\\cdot \\\\text{min_distance} \\\\]\n\n    where:\n        - \\\\[ \\\\text{max_distance} = \\\\max(|x|, |y|, |z|) \\\\]\n        - \\\\[ \\\\text{mid_distance} = \\\\text{total_distance} - \\\\text{max_distance} - \\\\text{min_distance} \\\\]\n        - \\\\[ \\\\text{min_distance} = \\\\min(|x|, |y|, |z|) \\\\]\n        - \\\\[ \\\\text{total_distance} = |x| + |y| + |z| \\\\]\n\n    Args:\n        x (Union[int, float]): Distance along the x-axis.\n        y (Union[int, float]): Distance along the y-axis.\n        z (Union[int, float]): Distance along the z-axis.\n\n    Returns:\n        float: The generalized octile distance between the points.\n    \"\"\"\n    x, y, z = abs(x), abs(y), abs(z)\n\n    # Find the maximum, middle, and minimum distances among the axes\n    max_distance = max(x, y, z)\n    min_distance = min(x, y, z)\n    mid_distance = x + y + z - max_distance - min_distance\n\n    # Calculate the octile distance\n    return max_distance + (math.sqrt(2) - 1) * mid_distance + (math.sqrt(3) - math.sqrt(2)) * min_distance\n</code></pre>"},{"location":"reference/core/environment/","title":"environment","text":""},{"location":"reference/core/environment/#mplanner.core.environment.DMove","title":"<code>DMove</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration for diagonal movement options in pathfinding algorithms.</p> <p>Specifies whether diagonal movement is allowed in grid-based pathfinding.</p> <p>Attributes:</p> Name Type Description <code>ALWAYS</code> <code>int</code> <p>Indicates that diagonal movement is always allowed.</p> <code>NEVER</code> <code>int</code> <p>Indicates that diagonal movement is never allowed.</p> Source code in <code>mplanner/core/environment.py</code> <pre><code>class DMove(Enum):\n    \"\"\"\n    Enumeration for diagonal movement options in pathfinding algorithms.\n\n    Specifies whether diagonal movement is allowed in grid-based pathfinding.\n\n    Attributes:\n        ALWAYS (int): Indicates that diagonal movement is always allowed.\n        NEVER (int): Indicates that diagonal movement is never allowed.\n    \"\"\"\n    ALWAYS = 1\n    NEVER = 0\n</code></pre>"},{"location":"reference/core/environment/#mplanner.core.environment.Grid","title":"<code>Grid</code>","text":"<p>A class representing a 3D grid, which serves as a map for spatial navigation and pathfinding.</p> <p>Initializes a new grid instance.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the grid. Defaults to 0.</p> <code>0</code> <code>height</code> <code>int</code> <p>The height of the grid. Defaults to 0.</p> <code>0</code> <code>depth</code> <code>int</code> <p>The depth of the grid. Defaults to 0.</p> <code>0</code> <code>matrix</code> <code>(optional, MatrixType)</code> <p>A 3D matrix (list or ndarray) where each element determines  if the corresponding node is walkable and its weight. If omitted, all nodes are set as walkable.</p> <code>None</code> <code>grid_id</code> <code>int</code> <p>A unique identifier for the grid. Defaults to None.</p> <code>None</code> <code>inverse</code> <code>bool</code> <p>If True, values in the matrix other than 0 are walkable; otherwise, 0 is walkable.</p> <code>False</code> Source code in <code>mplanner/core/environment.py</code> <pre><code>class Grid:\n    \"\"\"\n    A class representing a 3D grid, which serves as a map for spatial navigation and pathfinding.\n\n    Initializes a new grid instance.\n\n    Args:\n        width (int, optional): The width of the grid. Defaults to 0.\n        height (int, optional): The height of the grid. Defaults to 0.\n        depth (int, optional): The depth of the grid. Defaults to 0.\n        matrix (optional, MatrixType): A 3D matrix (list or ndarray) where each element determines \n            if the corresponding node is walkable and its weight. If omitted, all nodes are set as walkable.\n        grid_id (int, optional): A unique identifier for the grid. Defaults to None.\n        inverse (bool, optional): If True, values in the matrix other than 0 are walkable; otherwise, 0 is walkable.\n\n    \"\"\"\n    def __init__(\n        self,\n        width: int = 0,\n        height: int = 0,\n        depth: int = 0,\n        matrix: MatrixType = None,\n        grid_id: Optional[int] = None,\n        inverse: bool = False,\n    ):\n        self.width, self.height, self.depth = self._validate_dimensions(width, height, depth, matrix)\n        self.nodes = (\n            build_nodes(self.width, self.height, self.depth, matrix, inverse, grid_id)\n            if self.is_valid_grid()\n            else [[[]]]\n        )\n\n    def _validate_dimensions(self, width: int, height: int, depth: int, matrix: MatrixType) -&gt; tuple:\n        \"\"\"\n        Validates and determines the dimensions of the grid based on input parameters or matrix.\n\n        Args:\n            width (int): Specified width of the grid.\n            height (int): Specified height of the grid.\n            depth (int): Specified depth of the grid.\n            matrix (MatrixType): A 3D matrix to infer dimensions from, if provided.\n\n        Returns:\n            tuple: The (width, height, depth) of the grid.\n\n        Raises:\n            ValueError: If the matrix is not a valid 3D structure or is empty.\n        \"\"\"\n        if matrix is not None:\n            if not (\n                isinstance(matrix, (list, np.ndarray))\n                and len(matrix) &gt; 0\n                and len(matrix[0]) &gt; 0\n                and len(matrix[0][0]) &gt; 0\n            ):\n                raise ValueError(\"Provided matrix is not a 3D structure or is empty.\")\n            return len(matrix), len(matrix[0]), len(matrix[0][0])\n        return width, height, depth\n\n    def is_valid_grid(self) -&gt; bool:\n        \"\"\"\n        Determine if the grid has valid dimensions.\n        \"\"\"\n        return self.width &gt; 0 and self.height &gt; 0 and self.depth &gt; 0\n\n    def node(self, x: int, y: int, z: int) -&gt; Optional[GridNode]:\n        \"\"\"\n        Retrieve the node at a specific position.\n        \"\"\"\n        return self.nodes[x][y][z] if self.inside(x, y, z) else None\n\n    def inside(self, x: int, y: int, z: int) -&gt; bool:\n        \"\"\"\n        Check if a position is within the bounds of the grid.\n        \"\"\"\n        return 0 &lt;= x &lt; self.width and 0 &lt;= y &lt; self.height and 0 &lt;= z &lt; self.depth\n\n    def walkable(self, x: int, y: int, z: int) -&gt; bool:\n        \"\"\"\n        Check if a node is within bounds and walkable.\n        \"\"\"\n        return self.inside(x, y, z) and self.nodes[x][y][z].walkable\n\n    @lru_cache(maxsize=128)\n    def _calc_cost(self, x: int, y: int, z: int) -&gt; float:\n        \"\"\"\n        Compute the cost (Euclidean distance) between two adjacent nodes.\n        \"\"\"\n        return math.sqrt(x * x + y * y + z * z)\n\n    def calc_cost(self, node_a: GridNode, node_b: GridNode, weighted: bool = False) -&gt; float:\n        \"\"\"\n        Calculate the movement cost between two nodes.\n        \"\"\"\n        x = node_b.x - node_a.x\n        y = node_b.y - node_a.y\n        z = node_b.z - node_a.z\n        ng = self._calc_cost(x, y, z)\n        if weighted:\n            ng *= node_b.weight\n        return ng\n\n    def neighbors(\n        self,\n        node: GridNode,\n        diagonal_movement: int = DMove.NEVER,\n    ) -&gt; List[GridNode]:\n        \"\"\"\n        Retrieves all valid neighbors of a given node in a 3D grid.\n\n        Directional Movement Flags:\n            These variables represent the possible movement states in a 3D grid. They help determine whether \n            specific movements between nodes are allowed based on connectivity, obstacles, or boundaries.\n\n        Naming Convention:\n            - **`c`**: Refers to the **current plane** (Z-level of the node being analyzed).\n            - **`u`**: Refers to the **upper plane** (Z-level above the current node).\n            - **`l`**: Refers to the **lower plane** (Z-level below the current node).\n            - **`s`**: Refers to **straight movement** along major axes (X, Y, or Z).\n            - **`d`**: Refers to **diagonal movement** (combination of two or more axes, e.g., X+Y, X+Y+Z).\n            - **`ut`**: Represents movement directly upward (+Z direction).\n            - **`lb`**: Represents movement directly downward (-Z direction).\n\n        Variable Definitions:\n            ### Current Plane (Same Z-Level)\n            - `cs0`: Straight movement in the negative Y direction.\n            - `cs1`: Straight movement in the positive X direction.\n            - `cs2`: Straight movement in the positive Y direction.\n            - `cs3`: Straight movement in the negative X direction.\n            - `cd0`: Diagonal movement in the positive X, negative Y direction.\n            - `cd1`: Diagonal movement in the positive X, positive Y direction.\n            - `cd2`: Diagonal movement in the negative X, positive Y direction.\n            - `cd3`: Diagonal movement in the negative X, negative Y direction.\n\n            ### Upper Plane (Z-Level Above)\n            - `us0`: Straight movement in the negative Y direction on the upper plane.\n            - `us1`: Straight movement in the positive X direction on the upper plane.\n            - `us2`: Straight movement in the positive Y direction on the upper plane.\n            - `us3`: Straight movement in the negative X direction on the upper plane.\n            - `ud0`: Diagonal movement in the positive X, negative Y, and positive Z direction.\n            - `ud1`: Diagonal movement in the positive X, positive Y, and positive Z direction.\n            - `ud2`: Diagonal movement in the negative X, positive Y, and positive Z direction.\n            - `ud3`: Diagonal movement in the negative X, negative Y, and positive Z direction.\n            - `ut`: Movement directly upward in the positive Z direction.\n\n            ### Lower Plane (Z-Level Below)\n            - `ls0`: Straight movement in the negative Y direction on the lower plane.\n            - `ls1`: Straight movement in the positive X direction on the lower plane.\n            - `ls2`: Straight movement in the positive Y direction on the lower plane.\n            - `ls3`: Straight movement in the negative X direction on the lower plane.\n            - `ld0`: Diagonal movement in the positive X, negative Y, and negative Z direction.\n            - `ld1`: Diagonal movement in the positive X, positive Y, and negative Z direction.\n            - `ld2`: Diagonal movement in the negative X, positive Y, and negative Z direction.\n            - `ld3`: Diagonal movement in the negative X, negative Y, and negative Z direction.\n            - `lb`: Movement directly downward in the negative Z direction.\n\n        Usage:\n            These flags are set to `True` or `False` during the neighbor computation process, depending on whether \n            the corresponding movement is valid (e.g., not blocked by an obstacle or outside grid boundaries).\n\n            For example:\n            - If `cs0 = True`, straight movement in the negative Y direction on the current plane is valid.\n            - If `ud1 = False`, diagonal movement in the positive X, positive Y, and positive Z direction on the \n            upper plane is not allowed.\n\n        Args:\n            node (GridNode): The node for which neighbors are retrieved.\n            diagonal_movement (int, optional): Determines if diagonal movement is allowed. \n                See `DMove` enum for options. Defaults to DMove.NEVER.\n\n        Returns:\n            List[GridNode]: A list of all neighboring nodes.\n        \"\"\"\n\n        x, y, z = node.x, node.y, node.z\n\n        neighbors = []\n        cs0 = cd0 = cs1 = cd1 = cs2 = cd2 = cs3 = cd3 = False\n        us0 = ud0 = us1 = ud1 = us2 = ud2 = us3 = ud3 = ut = False  \n        ls0 = ld0 = ls1 = ld1 = ls2 = ld2 = ls3 = ld3 = lb = False\n\n        if self.walkable(x, y - 1, z):\n            neighbors.append(self.nodes[x][y - 1][z])\n            cs0 = True\n\n        if self.walkable(x + 1, y, z):\n            neighbors.append(self.nodes[x + 1][y][z])\n            cs1 = True\n\n        if self.walkable(x, y + 1, z):\n            neighbors.append(self.nodes[x][y + 1][z])\n            cs2 = True\n\n        if self.walkable(x - 1, y, z):\n            neighbors.append(self.nodes[x - 1][y][z])\n            cs3 = True\n\n        if self.walkable(x, y, z + 1):\n            neighbors.append(self.nodes[x][y][z + 1])\n            ut = True\n\n        if self.walkable(x, y, z - 1):\n            neighbors.append(self.nodes[x][y][z - 1])\n            lb = True\n\n        if node.connections:\n            neighbors.extend(node.connections)\n\n        if diagonal_movement == DMove.NEVER:\n            return neighbors\n\n        elif diagonal_movement == DMove.ALWAYS:\n            cd0 = cd1 = cd2 = cd3 = True\n            us0 = us1 = us2 = us3 = True\n            ls0 = ls1 = ls2 = ls3 = True\n\n        if cd0 and self.walkable(x + 1, y - 1, z):\n            neighbors.append(self.nodes[x + 1][y - 1][z])\n        else:\n            cd0 = False\n\n        if cd1 and self.walkable(x + 1, y + 1, z):\n            neighbors.append(self.nodes[x + 1][y + 1][z])\n        else:\n            cd1 = False\n\n        if cd2 and self.walkable(x - 1, y + 1, z):\n            neighbors.append(self.nodes[x - 1][y + 1][z])\n        else:\n            cd2 = False\n\n        if cd3 and self.walkable(x - 1, y - 1, z):\n            neighbors.append(self.nodes[x - 1][y - 1][z])\n        else:\n            cd3 = False\n\n        if us0 and self.walkable(x, y - 1, z + 1):\n            neighbors.append(self.nodes[x][y - 1][z + 1])\n        else:\n            us0 = False\n\n        if us1 and self.walkable(x + 1, y, z + 1):\n            neighbors.append(self.nodes[x + 1][y][z + 1])\n        else:\n            us1 = False\n\n        if us2 and self.walkable(x, y + 1, z + 1):\n            neighbors.append(self.nodes[x][y + 1][z + 1])\n        else:\n            us2 = False\n\n        if us3 and self.walkable(x - 1, y, z + 1):\n            neighbors.append(self.nodes[x - 1][y][z + 1])\n        else:\n            us3 = False\n\n        if ls0 and self.walkable(x, y - 1, z - 1):\n            neighbors.append(self.nodes[x][y - 1][z - 1])\n        else:\n            ls0 = False\n\n        if ls1 and self.walkable(x + 1, y, z - 1):\n            neighbors.append(self.nodes[x + 1][y][z - 1])\n        else:\n            ls1 = False\n\n        if ls2 and self.walkable(x, y + 1, z - 1):\n            neighbors.append(self.nodes[x][y + 1][z - 1])\n        else:\n            ls2 = False\n\n        if ls3 and self.walkable(x - 1, y, z - 1):\n            neighbors.append(self.nodes[x - 1][y][z - 1])\n        else:\n            ls3 = False\n\n        if diagonal_movement == DMove.ALWAYS:\n            ud0 = ud1 = ud2 = ud3 = True\n            ld0 = ld1 = ld2 = ld3 = True\n\n        if ud0 and self.walkable(x + 1, y - 1, z + 1):\n            neighbors.append(self.nodes[x + 1][y - 1][z + 1])\n\n        if ud1 and self.walkable(x + 1, y + 1, z + 1):\n            neighbors.append(self.nodes[x + 1][y + 1][z + 1])\n\n        if ud2 and self.walkable(x - 1, y + 1, z + 1):\n            neighbors.append(self.nodes[x - 1][y + 1][z + 1])\n\n        if ud3 and self.walkable(x - 1, y - 1, z + 1):\n            neighbors.append(self.nodes[x - 1][y - 1][z + 1])\n\n        if ld0 and self.walkable(x + 1, y - 1, z - 1):\n            neighbors.append(self.nodes[x + 1][y - 1][z - 1])\n\n        if ld1 and self.walkable(x + 1, y + 1, z - 1):\n            neighbors.append(self.nodes[x + 1][y + 1][z - 1])\n\n        if ld2 and self.walkable(x - 1, y + 1, z - 1):\n            neighbors.append(self.nodes[x - 1][y + 1][z - 1])\n\n        if ld3 and self.walkable(x - 1, y - 1, z - 1):\n            neighbors.append(self.nodes[x - 1][y - 1][z - 1])\n\n        return neighbors\n\n    def cleanup(self):\n        \"\"\"\n        Reset the state of all nodes in the grid.\n        Useful for clearing pathfinding metadata.\n        \"\"\"\n        for x_nodes in self.nodes:\n            for y_nodes in x_nodes:\n                for z_node in y_nodes:\n                    z_node.cleanup()\n\n    def visualize(\n        self,\n        path: Optional[List[Union[GridNode, Tuple]]] = None,\n        start: Optional[Union[GridNode, Tuple]] = None,\n        end: Optional[Union[GridNode, Tuple]] = None,\n        visualize_weight: bool = True,\n        save_html: bool = False,\n        save_to: str = \"./outputs/mplanner.html\",\n        always_show: bool = False,\n    ):\n        \"\"\"\n        Visualizes the grid and an optional path using Plotly in 3D.\n\n        Args:\n            path (list of Union[GridNode, Tuple], optional): The path to visualize. \n                Can include nodes or coordinate tuples.\n            start (Union[GridNode, Tuple], optional): The start position or node. \n                Defaults to the first node in the path if omitted.\n            end (Union[GridNode, Tuple], optional): The end position or node. \n                Defaults to the last node in the path if omitted.\n            visualize_weight (bool, optional): Whether to include node weights in the visualization. \n                Defaults to True.\n            save_html (bool, optional): If True, saves the visualization as an HTML file. \n                Defaults to False.\n            save_to (str, optional): Path to save the HTML file, if `save_html` is True. \n                Defaults to \"./outputs/mplanner.html\".\n            always_show (bool, optional): If True, always displays the visualization in a browser \n                even if saved to HTML. Defaults to False.\n\n        Notes:\n            - Requires Plotly for visualization. Ensure the `plotly` library is installed.\n        \"\"\"\n\n        if not USE_PLOTLY:\n            warnings.warn(\"Plotly is not installed. Please install it to use this feature.\")\n            return\n\n        # Extract obstacle and weight information directly from the grid\n        X, Y, Z, obstacle_values, weight_values = [], [], [], [], []\n        for x in range(self.width):\n            for y in range(self.height):\n                for z in range(self.depth):\n                    node = self.node(x, y, z)\n                    X.append(x)\n                    Y.append(y)\n                    Z.append(z)\n                    obstacle_values.append(0 if node.walkable else 1)\n                    weight_values.append(node.weight if node.walkable else 0)\n\n        # Create obstacle volume visualization\n        obstacle_vol = go.Volume(\n            x=np.array(X),\n            y=np.array(Y),\n            z=np.array(Z),\n            value=np.array(obstacle_values),\n            isomin=0.1,\n            isomax=1.0,\n            opacity=0.1,\n            surface_count=25,  # Increase for better visibility\n            colorscale=\"Greys\",\n            showscale=False,\n            name=\"Obstacles\",\n        )\n\n        # List of items to visualize\n        visualizations = [obstacle_vol]\n\n        # Create weight volume visualization\n        if visualize_weight:\n            weight_vol = go.Volume(\n                x=np.array(X),\n                y=np.array(Y),\n                z=np.array(Z),\n                value=np.array(weight_values),\n                isomin=1.01,  # Assuming default weight is 1, adjust as needed\n                isomax=max(weight_values) * 1.01,\n                opacity=0.5,  # Adjust for better visibility\n                surface_count=25,\n                colorscale=\"Viridis\",  # A different colorscale for distinction\n                showscale=True,\n                colorbar=dict(title=\"Weight\", ticks=\"outside\"),\n            )\n            visualizations.append(weight_vol)\n\n        # Add path visualization if path is provided\n        if path:\n            # Convert path to coordinate tuples\n            path = [p.identifier if isinstance(p, GridNode) else p for p in path]\n\n            # Create path visualization\n            path_x, path_y, path_z = zip(*path)\n            path_trace = go.Scatter3d(\n                x=path_x,\n                y=path_y,\n                z=path_z,\n                mode=\"markers+lines\",\n                marker=dict(size=6, color=\"red\", opacity=0.9),\n                line=dict(color=\"red\", width=3),\n                name=\"Path\",\n                hovertext=[f\"Step {i}: ({x}, {y}, {z})\" for i, (x, y, z) in enumerate(path)],\n                hoverinfo=\"text\",\n            )\n            visualizations.append(path_trace)\n\n            # Set start and end nodes if not provided\n            start = start or path[0]\n            end = end or path[-1]\n\n        # Add start and end node visualizations if available\n        if start:\n            start = start.identifier if isinstance(start, GridNode) else start\n            start_trace = go.Scatter3d(\n                x=[start[0]],\n                y=[start[1]],\n                z=[start[2]],\n                mode=\"markers\",\n                marker=dict(size=8, color=\"green\", symbol=\"diamond\"),\n                name=\"Start\",\n                hovertext=f\"Start: {start}\",\n                hoverinfo=\"text\",\n            )\n            visualizations.append(start_trace)\n\n        if end:\n            end = end.identifier if isinstance(end, GridNode) else end\n            end_trace = go.Scatter3d(\n                x=[end[0]],\n                y=[end[1]],\n                z=[end[2]],\n                mode=\"markers\",\n                marker=dict(size=8, color=\"blue\", symbol=\"diamond\"),\n                name=\"End\",\n                hovertext=f\"End: {end}\",\n                hoverinfo=\"text\",\n            )\n            visualizations.append(end_trace)\n\n        # Camera settings\n        # Set camera perpendicular to the z-axis\n        camera = dict(eye=dict(x=0.0, y=0.0, z=self.depth / 4))\n\n        # Specify layout\n        layout = go.Layout(\n            title=\"Motion Planning Visualization\",\n            scene=dict(\n                xaxis=dict(title=\"X-axis\", showbackground=True),\n                yaxis=dict(title=\"Y-axis\", showbackground=True),\n                zaxis=dict(title=\"Z-axis\", showbackground=True),\n                aspectmode=\"auto\",\n            ),\n            legend=dict(yanchor=\"top\", y=0.99, xanchor=\"left\", x=0.01),\n            autosize=True,\n            scene_camera=camera,\n        )\n\n        # Create figure\n        fig = go.Figure(data=visualizations, layout=layout)\n\n        # Save visualization to HTML file if specified\n        if save_html:\n            fig.write_html(save_to, auto_open=False)\n            print(f\"Visualization saved to: {save_to}\")\n\n        if always_show or not save_html:\n            fig.show()\n</code></pre>"},{"location":"reference/core/environment/#mplanner.core.environment.Grid.calc_cost","title":"<code>calc_cost(node_a, node_b, weighted=False)</code>","text":"<p>Calculate the movement cost between two nodes.</p> Source code in <code>mplanner/core/environment.py</code> <pre><code>def calc_cost(self, node_a: GridNode, node_b: GridNode, weighted: bool = False) -&gt; float:\n    \"\"\"\n    Calculate the movement cost between two nodes.\n    \"\"\"\n    x = node_b.x - node_a.x\n    y = node_b.y - node_a.y\n    z = node_b.z - node_a.z\n    ng = self._calc_cost(x, y, z)\n    if weighted:\n        ng *= node_b.weight\n    return ng\n</code></pre>"},{"location":"reference/core/environment/#mplanner.core.environment.Grid.cleanup","title":"<code>cleanup()</code>","text":"<p>Reset the state of all nodes in the grid. Useful for clearing pathfinding metadata.</p> Source code in <code>mplanner/core/environment.py</code> <pre><code>def cleanup(self):\n    \"\"\"\n    Reset the state of all nodes in the grid.\n    Useful for clearing pathfinding metadata.\n    \"\"\"\n    for x_nodes in self.nodes:\n        for y_nodes in x_nodes:\n            for z_node in y_nodes:\n                z_node.cleanup()\n</code></pre>"},{"location":"reference/core/environment/#mplanner.core.environment.Grid.inside","title":"<code>inside(x, y, z)</code>","text":"<p>Check if a position is within the bounds of the grid.</p> Source code in <code>mplanner/core/environment.py</code> <pre><code>def inside(self, x: int, y: int, z: int) -&gt; bool:\n    \"\"\"\n    Check if a position is within the bounds of the grid.\n    \"\"\"\n    return 0 &lt;= x &lt; self.width and 0 &lt;= y &lt; self.height and 0 &lt;= z &lt; self.depth\n</code></pre>"},{"location":"reference/core/environment/#mplanner.core.environment.Grid.is_valid_grid","title":"<code>is_valid_grid()</code>","text":"<p>Determine if the grid has valid dimensions.</p> Source code in <code>mplanner/core/environment.py</code> <pre><code>def is_valid_grid(self) -&gt; bool:\n    \"\"\"\n    Determine if the grid has valid dimensions.\n    \"\"\"\n    return self.width &gt; 0 and self.height &gt; 0 and self.depth &gt; 0\n</code></pre>"},{"location":"reference/core/environment/#mplanner.core.environment.Grid.neighbors","title":"<code>neighbors(node, diagonal_movement=DMove.NEVER)</code>","text":"<p>Retrieves all valid neighbors of a given node in a 3D grid.</p> Directional Movement Flags <p>These variables represent the possible movement states in a 3D grid. They help determine whether  specific movements between nodes are allowed based on connectivity, obstacles, or boundaries.</p> Naming Convention <ul> <li><code>c</code>: Refers to the current plane (Z-level of the node being analyzed).</li> <li><code>u</code>: Refers to the upper plane (Z-level above the current node).</li> <li><code>l</code>: Refers to the lower plane (Z-level below the current node).</li> <li><code>s</code>: Refers to straight movement along major axes (X, Y, or Z).</li> <li><code>d</code>: Refers to diagonal movement (combination of two or more axes, e.g., X+Y, X+Y+Z).</li> <li><code>ut</code>: Represents movement directly upward (+Z direction).</li> <li><code>lb</code>: Represents movement directly downward (-Z direction).</li> </ul> Variable Definitions Usage <p>These flags are set to <code>True</code> or <code>False</code> during the neighbor computation process, depending on whether  the corresponding movement is valid (e.g., not blocked by an obstacle or outside grid boundaries).</p> <p>For example: - If <code>cs0 = True</code>, straight movement in the negative Y direction on the current plane is valid. - If <code>ud1 = False</code>, diagonal movement in the positive X, positive Y, and positive Z direction on the  upper plane is not allowed.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>GridNode</code> <p>The node for which neighbors are retrieved.</p> required <code>diagonal_movement</code> <code>int</code> <p>Determines if diagonal movement is allowed.  See <code>DMove</code> enum for options. Defaults to DMove.NEVER.</p> <code>NEVER</code> <p>Returns:</p> Type Description <code>List[GridNode]</code> <p>List[GridNode]: A list of all neighboring nodes.</p> Source code in <code>mplanner/core/environment.py</code> <pre><code>def neighbors(\n    self,\n    node: GridNode,\n    diagonal_movement: int = DMove.NEVER,\n) -&gt; List[GridNode]:\n    \"\"\"\n    Retrieves all valid neighbors of a given node in a 3D grid.\n\n    Directional Movement Flags:\n        These variables represent the possible movement states in a 3D grid. They help determine whether \n        specific movements between nodes are allowed based on connectivity, obstacles, or boundaries.\n\n    Naming Convention:\n        - **`c`**: Refers to the **current plane** (Z-level of the node being analyzed).\n        - **`u`**: Refers to the **upper plane** (Z-level above the current node).\n        - **`l`**: Refers to the **lower plane** (Z-level below the current node).\n        - **`s`**: Refers to **straight movement** along major axes (X, Y, or Z).\n        - **`d`**: Refers to **diagonal movement** (combination of two or more axes, e.g., X+Y, X+Y+Z).\n        - **`ut`**: Represents movement directly upward (+Z direction).\n        - **`lb`**: Represents movement directly downward (-Z direction).\n\n    Variable Definitions:\n        ### Current Plane (Same Z-Level)\n        - `cs0`: Straight movement in the negative Y direction.\n        - `cs1`: Straight movement in the positive X direction.\n        - `cs2`: Straight movement in the positive Y direction.\n        - `cs3`: Straight movement in the negative X direction.\n        - `cd0`: Diagonal movement in the positive X, negative Y direction.\n        - `cd1`: Diagonal movement in the positive X, positive Y direction.\n        - `cd2`: Diagonal movement in the negative X, positive Y direction.\n        - `cd3`: Diagonal movement in the negative X, negative Y direction.\n\n        ### Upper Plane (Z-Level Above)\n        - `us0`: Straight movement in the negative Y direction on the upper plane.\n        - `us1`: Straight movement in the positive X direction on the upper plane.\n        - `us2`: Straight movement in the positive Y direction on the upper plane.\n        - `us3`: Straight movement in the negative X direction on the upper plane.\n        - `ud0`: Diagonal movement in the positive X, negative Y, and positive Z direction.\n        - `ud1`: Diagonal movement in the positive X, positive Y, and positive Z direction.\n        - `ud2`: Diagonal movement in the negative X, positive Y, and positive Z direction.\n        - `ud3`: Diagonal movement in the negative X, negative Y, and positive Z direction.\n        - `ut`: Movement directly upward in the positive Z direction.\n\n        ### Lower Plane (Z-Level Below)\n        - `ls0`: Straight movement in the negative Y direction on the lower plane.\n        - `ls1`: Straight movement in the positive X direction on the lower plane.\n        - `ls2`: Straight movement in the positive Y direction on the lower plane.\n        - `ls3`: Straight movement in the negative X direction on the lower plane.\n        - `ld0`: Diagonal movement in the positive X, negative Y, and negative Z direction.\n        - `ld1`: Diagonal movement in the positive X, positive Y, and negative Z direction.\n        - `ld2`: Diagonal movement in the negative X, positive Y, and negative Z direction.\n        - `ld3`: Diagonal movement in the negative X, negative Y, and negative Z direction.\n        - `lb`: Movement directly downward in the negative Z direction.\n\n    Usage:\n        These flags are set to `True` or `False` during the neighbor computation process, depending on whether \n        the corresponding movement is valid (e.g., not blocked by an obstacle or outside grid boundaries).\n\n        For example:\n        - If `cs0 = True`, straight movement in the negative Y direction on the current plane is valid.\n        - If `ud1 = False`, diagonal movement in the positive X, positive Y, and positive Z direction on the \n        upper plane is not allowed.\n\n    Args:\n        node (GridNode): The node for which neighbors are retrieved.\n        diagonal_movement (int, optional): Determines if diagonal movement is allowed. \n            See `DMove` enum for options. Defaults to DMove.NEVER.\n\n    Returns:\n        List[GridNode]: A list of all neighboring nodes.\n    \"\"\"\n\n    x, y, z = node.x, node.y, node.z\n\n    neighbors = []\n    cs0 = cd0 = cs1 = cd1 = cs2 = cd2 = cs3 = cd3 = False\n    us0 = ud0 = us1 = ud1 = us2 = ud2 = us3 = ud3 = ut = False  \n    ls0 = ld0 = ls1 = ld1 = ls2 = ld2 = ls3 = ld3 = lb = False\n\n    if self.walkable(x, y - 1, z):\n        neighbors.append(self.nodes[x][y - 1][z])\n        cs0 = True\n\n    if self.walkable(x + 1, y, z):\n        neighbors.append(self.nodes[x + 1][y][z])\n        cs1 = True\n\n    if self.walkable(x, y + 1, z):\n        neighbors.append(self.nodes[x][y + 1][z])\n        cs2 = True\n\n    if self.walkable(x - 1, y, z):\n        neighbors.append(self.nodes[x - 1][y][z])\n        cs3 = True\n\n    if self.walkable(x, y, z + 1):\n        neighbors.append(self.nodes[x][y][z + 1])\n        ut = True\n\n    if self.walkable(x, y, z - 1):\n        neighbors.append(self.nodes[x][y][z - 1])\n        lb = True\n\n    if node.connections:\n        neighbors.extend(node.connections)\n\n    if diagonal_movement == DMove.NEVER:\n        return neighbors\n\n    elif diagonal_movement == DMove.ALWAYS:\n        cd0 = cd1 = cd2 = cd3 = True\n        us0 = us1 = us2 = us3 = True\n        ls0 = ls1 = ls2 = ls3 = True\n\n    if cd0 and self.walkable(x + 1, y - 1, z):\n        neighbors.append(self.nodes[x + 1][y - 1][z])\n    else:\n        cd0 = False\n\n    if cd1 and self.walkable(x + 1, y + 1, z):\n        neighbors.append(self.nodes[x + 1][y + 1][z])\n    else:\n        cd1 = False\n\n    if cd2 and self.walkable(x - 1, y + 1, z):\n        neighbors.append(self.nodes[x - 1][y + 1][z])\n    else:\n        cd2 = False\n\n    if cd3 and self.walkable(x - 1, y - 1, z):\n        neighbors.append(self.nodes[x - 1][y - 1][z])\n    else:\n        cd3 = False\n\n    if us0 and self.walkable(x, y - 1, z + 1):\n        neighbors.append(self.nodes[x][y - 1][z + 1])\n    else:\n        us0 = False\n\n    if us1 and self.walkable(x + 1, y, z + 1):\n        neighbors.append(self.nodes[x + 1][y][z + 1])\n    else:\n        us1 = False\n\n    if us2 and self.walkable(x, y + 1, z + 1):\n        neighbors.append(self.nodes[x][y + 1][z + 1])\n    else:\n        us2 = False\n\n    if us3 and self.walkable(x - 1, y, z + 1):\n        neighbors.append(self.nodes[x - 1][y][z + 1])\n    else:\n        us3 = False\n\n    if ls0 and self.walkable(x, y - 1, z - 1):\n        neighbors.append(self.nodes[x][y - 1][z - 1])\n    else:\n        ls0 = False\n\n    if ls1 and self.walkable(x + 1, y, z - 1):\n        neighbors.append(self.nodes[x + 1][y][z - 1])\n    else:\n        ls1 = False\n\n    if ls2 and self.walkable(x, y + 1, z - 1):\n        neighbors.append(self.nodes[x][y + 1][z - 1])\n    else:\n        ls2 = False\n\n    if ls3 and self.walkable(x - 1, y, z - 1):\n        neighbors.append(self.nodes[x - 1][y][z - 1])\n    else:\n        ls3 = False\n\n    if diagonal_movement == DMove.ALWAYS:\n        ud0 = ud1 = ud2 = ud3 = True\n        ld0 = ld1 = ld2 = ld3 = True\n\n    if ud0 and self.walkable(x + 1, y - 1, z + 1):\n        neighbors.append(self.nodes[x + 1][y - 1][z + 1])\n\n    if ud1 and self.walkable(x + 1, y + 1, z + 1):\n        neighbors.append(self.nodes[x + 1][y + 1][z + 1])\n\n    if ud2 and self.walkable(x - 1, y + 1, z + 1):\n        neighbors.append(self.nodes[x - 1][y + 1][z + 1])\n\n    if ud3 and self.walkable(x - 1, y - 1, z + 1):\n        neighbors.append(self.nodes[x - 1][y - 1][z + 1])\n\n    if ld0 and self.walkable(x + 1, y - 1, z - 1):\n        neighbors.append(self.nodes[x + 1][y - 1][z - 1])\n\n    if ld1 and self.walkable(x + 1, y + 1, z - 1):\n        neighbors.append(self.nodes[x + 1][y + 1][z - 1])\n\n    if ld2 and self.walkable(x - 1, y + 1, z - 1):\n        neighbors.append(self.nodes[x - 1][y + 1][z - 1])\n\n    if ld3 and self.walkable(x - 1, y - 1, z - 1):\n        neighbors.append(self.nodes[x - 1][y - 1][z - 1])\n\n    return neighbors\n</code></pre>"},{"location":"reference/core/environment/#mplanner.core.environment.Grid.neighbors--current-plane-same-z-level","title":"Current Plane (Same Z-Level)","text":"<ul> <li><code>cs0</code>: Straight movement in the negative Y direction.</li> <li><code>cs1</code>: Straight movement in the positive X direction.</li> <li><code>cs2</code>: Straight movement in the positive Y direction.</li> <li><code>cs3</code>: Straight movement in the negative X direction.</li> <li><code>cd0</code>: Diagonal movement in the positive X, negative Y direction.</li> <li><code>cd1</code>: Diagonal movement in the positive X, positive Y direction.</li> <li><code>cd2</code>: Diagonal movement in the negative X, positive Y direction.</li> <li><code>cd3</code>: Diagonal movement in the negative X, negative Y direction.</li> </ul>"},{"location":"reference/core/environment/#mplanner.core.environment.Grid.neighbors--upper-plane-z-level-above","title":"Upper Plane (Z-Level Above)","text":"<ul> <li><code>us0</code>: Straight movement in the negative Y direction on the upper plane.</li> <li><code>us1</code>: Straight movement in the positive X direction on the upper plane.</li> <li><code>us2</code>: Straight movement in the positive Y direction on the upper plane.</li> <li><code>us3</code>: Straight movement in the negative X direction on the upper plane.</li> <li><code>ud0</code>: Diagonal movement in the positive X, negative Y, and positive Z direction.</li> <li><code>ud1</code>: Diagonal movement in the positive X, positive Y, and positive Z direction.</li> <li><code>ud2</code>: Diagonal movement in the negative X, positive Y, and positive Z direction.</li> <li><code>ud3</code>: Diagonal movement in the negative X, negative Y, and positive Z direction.</li> <li><code>ut</code>: Movement directly upward in the positive Z direction.</li> </ul>"},{"location":"reference/core/environment/#mplanner.core.environment.Grid.neighbors--lower-plane-z-level-below","title":"Lower Plane (Z-Level Below)","text":"<ul> <li><code>ls0</code>: Straight movement in the negative Y direction on the lower plane.</li> <li><code>ls1</code>: Straight movement in the positive X direction on the lower plane.</li> <li><code>ls2</code>: Straight movement in the positive Y direction on the lower plane.</li> <li><code>ls3</code>: Straight movement in the negative X direction on the lower plane.</li> <li><code>ld0</code>: Diagonal movement in the positive X, negative Y, and negative Z direction.</li> <li><code>ld1</code>: Diagonal movement in the positive X, positive Y, and negative Z direction.</li> <li><code>ld2</code>: Diagonal movement in the negative X, positive Y, and negative Z direction.</li> <li><code>ld3</code>: Diagonal movement in the negative X, negative Y, and negative Z direction.</li> <li><code>lb</code>: Movement directly downward in the negative Z direction.</li> </ul>"},{"location":"reference/core/environment/#mplanner.core.environment.Grid.node","title":"<code>node(x, y, z)</code>","text":"<p>Retrieve the node at a specific position.</p> Source code in <code>mplanner/core/environment.py</code> <pre><code>def node(self, x: int, y: int, z: int) -&gt; Optional[GridNode]:\n    \"\"\"\n    Retrieve the node at a specific position.\n    \"\"\"\n    return self.nodes[x][y][z] if self.inside(x, y, z) else None\n</code></pre>"},{"location":"reference/core/environment/#mplanner.core.environment.Grid.visualize","title":"<code>visualize(path=None, start=None, end=None, visualize_weight=True, save_html=False, save_to='./outputs/mplanner.html', always_show=False)</code>","text":"<p>Visualizes the grid and an optional path using Plotly in 3D.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>list of Union[GridNode, Tuple]</code> <p>The path to visualize.  Can include nodes or coordinate tuples.</p> <code>None</code> <code>start</code> <code>Union[GridNode, Tuple]</code> <p>The start position or node.  Defaults to the first node in the path if omitted.</p> <code>None</code> <code>end</code> <code>Union[GridNode, Tuple]</code> <p>The end position or node.  Defaults to the last node in the path if omitted.</p> <code>None</code> <code>visualize_weight</code> <code>bool</code> <p>Whether to include node weights in the visualization.  Defaults to True.</p> <code>True</code> <code>save_html</code> <code>bool</code> <p>If True, saves the visualization as an HTML file.  Defaults to False.</p> <code>False</code> <code>save_to</code> <code>str</code> <p>Path to save the HTML file, if <code>save_html</code> is True.  Defaults to \"./outputs/mplanner.html\".</p> <code>'./outputs/mplanner.html'</code> <code>always_show</code> <code>bool</code> <p>If True, always displays the visualization in a browser  even if saved to HTML. Defaults to False.</p> <code>False</code> Notes <ul> <li>Requires Plotly for visualization. Ensure the <code>plotly</code> library is installed.</li> </ul> Source code in <code>mplanner/core/environment.py</code> <pre><code>def visualize(\n    self,\n    path: Optional[List[Union[GridNode, Tuple]]] = None,\n    start: Optional[Union[GridNode, Tuple]] = None,\n    end: Optional[Union[GridNode, Tuple]] = None,\n    visualize_weight: bool = True,\n    save_html: bool = False,\n    save_to: str = \"./outputs/mplanner.html\",\n    always_show: bool = False,\n):\n    \"\"\"\n    Visualizes the grid and an optional path using Plotly in 3D.\n\n    Args:\n        path (list of Union[GridNode, Tuple], optional): The path to visualize. \n            Can include nodes or coordinate tuples.\n        start (Union[GridNode, Tuple], optional): The start position or node. \n            Defaults to the first node in the path if omitted.\n        end (Union[GridNode, Tuple], optional): The end position or node. \n            Defaults to the last node in the path if omitted.\n        visualize_weight (bool, optional): Whether to include node weights in the visualization. \n            Defaults to True.\n        save_html (bool, optional): If True, saves the visualization as an HTML file. \n            Defaults to False.\n        save_to (str, optional): Path to save the HTML file, if `save_html` is True. \n            Defaults to \"./outputs/mplanner.html\".\n        always_show (bool, optional): If True, always displays the visualization in a browser \n            even if saved to HTML. Defaults to False.\n\n    Notes:\n        - Requires Plotly for visualization. Ensure the `plotly` library is installed.\n    \"\"\"\n\n    if not USE_PLOTLY:\n        warnings.warn(\"Plotly is not installed. Please install it to use this feature.\")\n        return\n\n    # Extract obstacle and weight information directly from the grid\n    X, Y, Z, obstacle_values, weight_values = [], [], [], [], []\n    for x in range(self.width):\n        for y in range(self.height):\n            for z in range(self.depth):\n                node = self.node(x, y, z)\n                X.append(x)\n                Y.append(y)\n                Z.append(z)\n                obstacle_values.append(0 if node.walkable else 1)\n                weight_values.append(node.weight if node.walkable else 0)\n\n    # Create obstacle volume visualization\n    obstacle_vol = go.Volume(\n        x=np.array(X),\n        y=np.array(Y),\n        z=np.array(Z),\n        value=np.array(obstacle_values),\n        isomin=0.1,\n        isomax=1.0,\n        opacity=0.1,\n        surface_count=25,  # Increase for better visibility\n        colorscale=\"Greys\",\n        showscale=False,\n        name=\"Obstacles\",\n    )\n\n    # List of items to visualize\n    visualizations = [obstacle_vol]\n\n    # Create weight volume visualization\n    if visualize_weight:\n        weight_vol = go.Volume(\n            x=np.array(X),\n            y=np.array(Y),\n            z=np.array(Z),\n            value=np.array(weight_values),\n            isomin=1.01,  # Assuming default weight is 1, adjust as needed\n            isomax=max(weight_values) * 1.01,\n            opacity=0.5,  # Adjust for better visibility\n            surface_count=25,\n            colorscale=\"Viridis\",  # A different colorscale for distinction\n            showscale=True,\n            colorbar=dict(title=\"Weight\", ticks=\"outside\"),\n        )\n        visualizations.append(weight_vol)\n\n    # Add path visualization if path is provided\n    if path:\n        # Convert path to coordinate tuples\n        path = [p.identifier if isinstance(p, GridNode) else p for p in path]\n\n        # Create path visualization\n        path_x, path_y, path_z = zip(*path)\n        path_trace = go.Scatter3d(\n            x=path_x,\n            y=path_y,\n            z=path_z,\n            mode=\"markers+lines\",\n            marker=dict(size=6, color=\"red\", opacity=0.9),\n            line=dict(color=\"red\", width=3),\n            name=\"Path\",\n            hovertext=[f\"Step {i}: ({x}, {y}, {z})\" for i, (x, y, z) in enumerate(path)],\n            hoverinfo=\"text\",\n        )\n        visualizations.append(path_trace)\n\n        # Set start and end nodes if not provided\n        start = start or path[0]\n        end = end or path[-1]\n\n    # Add start and end node visualizations if available\n    if start:\n        start = start.identifier if isinstance(start, GridNode) else start\n        start_trace = go.Scatter3d(\n            x=[start[0]],\n            y=[start[1]],\n            z=[start[2]],\n            mode=\"markers\",\n            marker=dict(size=8, color=\"green\", symbol=\"diamond\"),\n            name=\"Start\",\n            hovertext=f\"Start: {start}\",\n            hoverinfo=\"text\",\n        )\n        visualizations.append(start_trace)\n\n    if end:\n        end = end.identifier if isinstance(end, GridNode) else end\n        end_trace = go.Scatter3d(\n            x=[end[0]],\n            y=[end[1]],\n            z=[end[2]],\n            mode=\"markers\",\n            marker=dict(size=8, color=\"blue\", symbol=\"diamond\"),\n            name=\"End\",\n            hovertext=f\"End: {end}\",\n            hoverinfo=\"text\",\n        )\n        visualizations.append(end_trace)\n\n    # Camera settings\n    # Set camera perpendicular to the z-axis\n    camera = dict(eye=dict(x=0.0, y=0.0, z=self.depth / 4))\n\n    # Specify layout\n    layout = go.Layout(\n        title=\"Motion Planning Visualization\",\n        scene=dict(\n            xaxis=dict(title=\"X-axis\", showbackground=True),\n            yaxis=dict(title=\"Y-axis\", showbackground=True),\n            zaxis=dict(title=\"Z-axis\", showbackground=True),\n            aspectmode=\"auto\",\n        ),\n        legend=dict(yanchor=\"top\", y=0.99, xanchor=\"left\", x=0.01),\n        autosize=True,\n        scene_camera=camera,\n    )\n\n    # Create figure\n    fig = go.Figure(data=visualizations, layout=layout)\n\n    # Save visualization to HTML file if specified\n    if save_html:\n        fig.write_html(save_to, auto_open=False)\n        print(f\"Visualization saved to: {save_to}\")\n\n    if always_show or not save_html:\n        fig.show()\n</code></pre>"},{"location":"reference/core/environment/#mplanner.core.environment.Grid.walkable","title":"<code>walkable(x, y, z)</code>","text":"<p>Check if a node is within bounds and walkable.</p> Source code in <code>mplanner/core/environment.py</code> <pre><code>def walkable(self, x: int, y: int, z: int) -&gt; bool:\n    \"\"\"\n    Check if a node is within bounds and walkable.\n    \"\"\"\n    return self.inside(x, y, z) and self.nodes[x][y][z].walkable\n</code></pre>"},{"location":"reference/core/environment/#mplanner.core.environment.GridNode","title":"<code>GridNode</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Node</code></p> <p>Represents a node in a grid for pathfinding algorithms.</p> <p>Extends the basic <code>Node</code> class by including spatial coordinates and  grid-specific attributes, such as walkability, weight, and connections  to neighboring nodes.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>int</code> <p>The x-coordinate of the node in the grid.</p> <code>y</code> <code>int</code> <p>The y-coordinate of the node in the grid.</p> <code>z</code> <code>int</code> <p>The z-coordinate of the node in the grid.</p> <code>walkable</code> <code>bool</code> <p>Indicates whether this node is passable or blocked.</p> <code>weight</code> <code>float</code> <p>The traversal cost associated with this node, used in weighted algorithms.</p> <code>grid_id</code> <code>Optional[int]</code> <p>Identifier for the grid this node belongs to. Useful for managing multiple grids.</p> <code>connections</code> <code>List[GridNode]</code> <p>The list of neighboring nodes connected to this node.</p> Source code in <code>mplanner/core/environment.py</code> <pre><code>@dataclass\nclass GridNode(Node):\n    \"\"\"\n    Represents a node in a grid for pathfinding algorithms.\n\n    Extends the basic `Node` class by including spatial coordinates and \n    grid-specific attributes, such as walkability, weight, and connections \n    to neighboring nodes.\n\n    Attributes:\n        x (int): The x-coordinate of the node in the grid.\n        y (int): The y-coordinate of the node in the grid.\n        z (int): The z-coordinate of the node in the grid.\n        walkable (bool): Indicates whether this node is passable or blocked.\n        weight (float): The traversal cost associated with this node, used in weighted algorithms.\n        grid_id (Optional[int]): Identifier for the grid this node belongs to. Useful for managing multiple grids.\n        connections (List[GridNode]): The list of neighboring nodes connected to this node.\n    \"\"\"\n    x: int = 0\n    y: int = 0\n    z: int = 0\n\n    walkable: bool = True\n    weight: float = 1.0\n    grid_id: Optional[int] = None\n\n    connections: List[\"GridNode\"] = field(default_factory=list)\n\n    def __post_init__(self):\n        super().__init__()\n        self.identifier: Tuple = (\n            (self.x, self.y, self.z) if self.grid_id is None else (self.x, self.y, self.z, self.grid_id)\n        )\n\n    def __iter__(self):\n        yield self.x\n        yield self.y\n        yield self.z\n        if self.grid_id is not None:\n            yield self.grid_id\n\n    def connect(self, other_node: \"GridNode\"):\n        \"\"\"\n        Connects this node to another node by adding the other node to its connections.\n        \"\"\"\n        self.connections.append(other_node)\n</code></pre>"},{"location":"reference/core/environment/#mplanner.core.environment.GridNode.connect","title":"<code>connect(other_node)</code>","text":"<p>Connects this node to another node by adding the other node to its connections.</p> Source code in <code>mplanner/core/environment.py</code> <pre><code>def connect(self, other_node: \"GridNode\"):\n    \"\"\"\n    Connects this node to another node by adding the other node to its connections.\n    \"\"\"\n    self.connections.append(other_node)\n</code></pre>"},{"location":"reference/core/environment/#mplanner.core.environment.Node","title":"<code>Node</code>  <code>dataclass</code>","text":"<p>Basic node class to store calculated values for pathfinding algorithms.</p> <p>Attributes:</p> Name Type Description <code>h</code> <code>float</code> <p>Heuristic cost from this node to the goal (used in A*).</p> <code>g</code> <code>float</code> <p>Actual cost from the start node to this node.</p> <code>f</code> <code>float</code> <p>Total estimated cost of the path through this node (f = g + h).</p> <code>opened</code> <code>int</code> <p>Number of times this node has been opened during the search.</p> <code>closed</code> <code>bool</code> <p>Indicates whether this node has been processed and closed.</p> <code>parent</code> <code>Optional[Node]</code> <p>Reference to the parent node, used for backtracking the path.</p> <code>retain_count</code> <code>int</code> <p>Counter for recursion tracking in IDA*.</p> <code>tested</code> <code>bool</code> <p>Indicates if the node has been tested (used in IDA* and Jump-Point-Search).</p> Source code in <code>mplanner/core/environment.py</code> <pre><code>@dataclass\nclass Node:\n    \"\"\"\n    Basic node class to store calculated values for pathfinding algorithms.\n\n    Attributes:\n        h (float): Heuristic cost from this node to the goal (used in A*).\n        g (float): Actual cost from the start node to this node.\n        f (float): Total estimated cost of the path through this node (f = g + h).\n        opened (int): Number of times this node has been opened during the search.\n        closed (bool): Indicates whether this node has been processed and closed.\n        parent (Optional[Node]): Reference to the parent node, used for backtracking the path.\n        retain_count (int): Counter for recursion tracking in IDA*.\n        tested (bool): Indicates if the node has been tested (used in IDA* and Jump-Point-Search).\n    \"\"\"\n    h: float = field(default=0.0)\n    g: float = field(default=0.0)\n    f: float = field(default=0.0)\n    opened: int = field(default=0)\n    closed: bool = field(default=False)\n    parent: Optional[\"Node\"] = field(default=None)\n    retain_count: int = field(default=0)\n    tested: bool = field(default=False)\n\n    def __lt__(self, other: \"Node\") -&gt; bool:\n        return self.f &lt; other.f\n\n    def cleanup(self):\n        \"\"\"\n        Resets all node values to their default state for reuse in pathfinding.\n        \"\"\"\n        self.h = 0.0\n        self.g = 0.0\n        self.f = 0.0\n        self.opened = 0\n        self.closed = False\n        self.parent = None\n        self.retain_count = 0\n        self.tested = False\n</code></pre>"},{"location":"reference/core/environment/#mplanner.core.environment.Node.cleanup","title":"<code>cleanup()</code>","text":"<p>Resets all node values to their default state for reuse in pathfinding.</p> Source code in <code>mplanner/core/environment.py</code> <pre><code>def cleanup(self):\n    \"\"\"\n    Resets all node values to their default state for reuse in pathfinding.\n    \"\"\"\n    self.h = 0.0\n    self.g = 0.0\n    self.f = 0.0\n    self.opened = 0\n    self.closed = False\n    self.parent = None\n    self.retain_count = 0\n    self.tested = False\n</code></pre>"},{"location":"reference/core/environment/#mplanner.core.environment.World","title":"<code>World</code>","text":"<p>Represents a world consisting of multiple interconnected grids.</p> <p>The world manages navigation and cost calculations across these grids.</p> <p>Parameters:</p> Name Type Description Default <code>grids</code> <code>Dict[int, Grid]</code> <p>A dictionary of grids in the world, where the key  is the grid ID and the value is the corresponding <code>Grid</code> object.</p> required Source code in <code>mplanner/core/environment.py</code> <pre><code>class World:\n    \"\"\"\n    Represents a world consisting of multiple interconnected grids.\n\n    The world manages navigation and cost calculations across these grids.\n\n    Args:\n        grids (Dict[int, Grid]): A dictionary of grids in the world, where the key \n            is the grid ID and the value is the corresponding `Grid` object.\n    \"\"\"\n    def __init__(self, grids: Dict[int, Grid]):\n        self.grids = grids\n\n    def neighbors(self, node: GridNode, diagonal_movement: int) -&gt; List[GridNode]:\n        \"\"\"\n        Retrieves the neighbors of a given node, accounting for its grid.\n\n        Args:\n            node (GridNode): The node for which neighbors are retrieved.\n            diagonal_movement (int): Specifies if diagonal movement is allowed. \n                Refer to the `DMove` enum for valid options (e.g., never, always).\n\n        Returns:\n            List[GridNode]: A list of neighboring nodes for the given node, including potential \n                connections to other grids if supported.\n        \"\"\"\n        return self.grids[node.grid_id].neighbors(node, diagonal_movement=diagonal_movement)\n\n    def calc_cost(self, node_a: GridNode, node_b: GridNode, weighted: bool = False) -&gt; float:\n        \"\"\"\n        Calculates the movement cost between two nodes, potentially across grids.\n\n        Args:\n            node_a (GridNode): The starting node.\n            node_b (GridNode): The target node.\n            weighted (bool, optional): Whether to factor in node weights for the cost calculation. \n                Defaults to False.\n\n        Returns:\n            float: The calculated movement cost between `node_a` and `node_b`.\n\n        Notes:\n            - Currently, the method only considers nodes within the same grid. \n            - For nodes in different grids, inter-grid cost calculation is a placeholder.\n        \"\"\"\n        # TODO: Handle inter-grid cost calculation when `node_a.grid_id != node_b.grid_id`.\n        # For now, only intra-grid costs are considered.\n        return self.grids[node_a.grid_id].calc_cost(node_a, node_b, weighted=weighted)\n\n    def cleanup(self):\n        \"\"\"\n        Reset all grids in the world by clearing any pathfinding metadata or temporary states.\n        \"\"\"\n        for grid in self.grids.values():\n            grid.cleanup()\n</code></pre>"},{"location":"reference/core/environment/#mplanner.core.environment.World.calc_cost","title":"<code>calc_cost(node_a, node_b, weighted=False)</code>","text":"<p>Calculates the movement cost between two nodes, potentially across grids.</p> <p>Parameters:</p> Name Type Description Default <code>node_a</code> <code>GridNode</code> <p>The starting node.</p> required <code>node_b</code> <code>GridNode</code> <p>The target node.</p> required <code>weighted</code> <code>bool</code> <p>Whether to factor in node weights for the cost calculation.  Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calculated movement cost between <code>node_a</code> and <code>node_b</code>.</p> Notes <ul> <li>Currently, the method only considers nodes within the same grid. </li> <li>For nodes in different grids, inter-grid cost calculation is a placeholder.</li> </ul> Source code in <code>mplanner/core/environment.py</code> <pre><code>def calc_cost(self, node_a: GridNode, node_b: GridNode, weighted: bool = False) -&gt; float:\n    \"\"\"\n    Calculates the movement cost between two nodes, potentially across grids.\n\n    Args:\n        node_a (GridNode): The starting node.\n        node_b (GridNode): The target node.\n        weighted (bool, optional): Whether to factor in node weights for the cost calculation. \n            Defaults to False.\n\n    Returns:\n        float: The calculated movement cost between `node_a` and `node_b`.\n\n    Notes:\n        - Currently, the method only considers nodes within the same grid. \n        - For nodes in different grids, inter-grid cost calculation is a placeholder.\n    \"\"\"\n    # TODO: Handle inter-grid cost calculation when `node_a.grid_id != node_b.grid_id`.\n    # For now, only intra-grid costs are considered.\n    return self.grids[node_a.grid_id].calc_cost(node_a, node_b, weighted=weighted)\n</code></pre>"},{"location":"reference/core/environment/#mplanner.core.environment.World.cleanup","title":"<code>cleanup()</code>","text":"<p>Reset all grids in the world by clearing any pathfinding metadata or temporary states.</p> Source code in <code>mplanner/core/environment.py</code> <pre><code>def cleanup(self):\n    \"\"\"\n    Reset all grids in the world by clearing any pathfinding metadata or temporary states.\n    \"\"\"\n    for grid in self.grids.values():\n        grid.cleanup()\n</code></pre>"},{"location":"reference/core/environment/#mplanner.core.environment.World.neighbors","title":"<code>neighbors(node, diagonal_movement)</code>","text":"<p>Retrieves the neighbors of a given node, accounting for its grid.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>GridNode</code> <p>The node for which neighbors are retrieved.</p> required <code>diagonal_movement</code> <code>int</code> <p>Specifies if diagonal movement is allowed.  Refer to the <code>DMove</code> enum for valid options (e.g., never, always).</p> required <p>Returns:</p> Type Description <code>List[GridNode]</code> <p>List[GridNode]: A list of neighboring nodes for the given node, including potential  connections to other grids if supported.</p> Source code in <code>mplanner/core/environment.py</code> <pre><code>def neighbors(self, node: GridNode, diagonal_movement: int) -&gt; List[GridNode]:\n    \"\"\"\n    Retrieves the neighbors of a given node, accounting for its grid.\n\n    Args:\n        node (GridNode): The node for which neighbors are retrieved.\n        diagonal_movement (int): Specifies if diagonal movement is allowed. \n            Refer to the `DMove` enum for valid options (e.g., never, always).\n\n    Returns:\n        List[GridNode]: A list of neighboring nodes for the given node, including potential \n            connections to other grids if supported.\n    \"\"\"\n    return self.grids[node.grid_id].neighbors(node, diagonal_movement=diagonal_movement)\n</code></pre>"},{"location":"reference/core/environment/#mplanner.core.environment.build_nodes","title":"<code>build_nodes(width, height, depth, matrix=None, inverse=False, grid_id=None)</code>","text":"<p>Creates a 3D grid of <code>GridNode</code> objects based on specified dimensions and matrix.</p> <p>If a matrix is provided, it determines the walkability and weight of the nodes. Otherwise, all nodes are initialized as walkable with a default weight of 1.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The number of nodes along the x-axis.</p> required <code>height</code> <code>int</code> <p>The number of nodes along the y-axis.</p> required <code>depth</code> <code>int</code> <p>The number of nodes along the z-axis.</p> required <code>matrix</code> <code>(optional, MatrixType)</code> <p>A 3D matrix (list of lists of lists or numpy array) specifying walkability  and weights: - <code>0</code> or values &lt;= 0 indicate non-walkable nodes (obstacles). - Positive values indicate walkable nodes, with the value representing the weight. If <code>inverse=True</code>, the interpretation of values is reversed.</p> <code>None</code> <code>inverse</code> <code>bool</code> <p>If True, reverses the walkability condition: - Non-zero or positive values indicate obstacles. - <code>0</code> or negative values indicate walkable nodes. Defaults to False.</p> <code>False</code> <code>grid_id</code> <code>int</code> <p>An identifier for the grid.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[List[List[GridNode]]]</code> <p>List[List[List[GridNode]]]: A 3D list of <code>GridNode</code> objects representing the grid.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; build_nodes(2, 2, 2, matrix=[[[1, 0], [0, 1]], [[1, 1], [0, 0]]])\n[[[GridNode(x=0, y=0, z=0, walkable=True, weight=1), GridNode(x=0, y=0, z=1, walkable=False, weight=0)], \n  [GridNode(x=0, y=1, z=0, walkable=False, weight=0), GridNode(x=0, y=1, z=1, walkable=True, weight=1)]],\n [[GridNode(x=1, y=0, z=0, walkable=True, weight=1), GridNode(x=1, y=0, z=1, walkable=True, weight=1)], \n  [GridNode(x=1, y=1, z=0, walkable=False, weight=0), GridNode(x=1, y=1, z=1, walkable=False, weight=0)]]]\n</code></pre> Notes <ul> <li>If no <code>matrix</code> is provided, all nodes will default to walkable with weight = 1.</li> <li>The <code>grid_id</code> allows differentiation of nodes across multiple grids.</li> </ul> Source code in <code>mplanner/core/environment.py</code> <pre><code>def build_nodes(\n    width: int,\n    height: int,\n    depth: int,\n    matrix: MatrixType = None,\n    inverse: bool = False,\n    grid_id: Optional[int] = None,\n) -&gt; List[List[List[GridNode]]]:\n    \"\"\"\n    Creates a 3D grid of `GridNode` objects based on specified dimensions and matrix.\n\n    If a matrix is provided, it determines the walkability and weight of the nodes.\n    Otherwise, all nodes are initialized as walkable with a default weight of 1.\n\n    Args:\n        width (int): The number of nodes along the x-axis.\n        height (int): The number of nodes along the y-axis.\n        depth (int): The number of nodes along the z-axis.\n        matrix (optional, MatrixType): A 3D matrix (list of lists of lists or numpy array) specifying walkability \n            and weights:\n            - `0` or values &lt;= 0 indicate non-walkable nodes (obstacles).\n            - Positive values indicate walkable nodes, with the value representing the weight.\n            If `inverse=True`, the interpretation of values is reversed.\n        inverse (bool, optional): If True, reverses the walkability condition:\n            - Non-zero or positive values indicate obstacles.\n            - `0` or negative values indicate walkable nodes.\n            Defaults to False.\n        grid_id (int, optional): An identifier for the grid.\n\n    Returns:\n        List[List[List[GridNode]]]: A 3D list of `GridNode` objects representing the grid.\n\n    Examples:\n        &gt;&gt;&gt; build_nodes(2, 2, 2, matrix=[[[1, 0], [0, 1]], [[1, 1], [0, 0]]])\n        [[[GridNode(x=0, y=0, z=0, walkable=True, weight=1), GridNode(x=0, y=0, z=1, walkable=False, weight=0)], \n          [GridNode(x=0, y=1, z=0, walkable=False, weight=0), GridNode(x=0, y=1, z=1, walkable=True, weight=1)]],\n         [[GridNode(x=1, y=0, z=0, walkable=True, weight=1), GridNode(x=1, y=0, z=1, walkable=True, weight=1)], \n          [GridNode(x=1, y=1, z=0, walkable=False, weight=0), GridNode(x=1, y=1, z=1, walkable=False, weight=0)]]]\n\n    Notes:\n        - If no `matrix` is provided, all nodes will default to walkable with weight = 1.\n        - The `grid_id` allows differentiation of nodes across multiple grids.\n    \"\"\"\n    nodes: List[List[List[GridNode]]] = []\n    use_matrix = matrix is not None\n\n    for x in range(width):\n        nodes.append([])\n        for y in range(height):\n            nodes[x].append([])\n            for z in range(depth):\n                # Determine weight and walkability based on the matrix or defaults\n                weight = int(matrix[x][y][z]) if use_matrix else 1\n                walkable = weight &lt;= 0 if inverse else weight &gt;= 1\n\n                # Append a new GridNode to the grid\n                nodes[x][y].append(GridNode(x=x, y=y, z=z, walkable=walkable, weight=weight, grid_id=grid_id))\n\n    return nodes\n</code></pre>"},{"location":"reference/core/planner/","title":"planner","text":""},{"location":"reference/core/planner/#mplanner.core.planner.Planner","title":"<code>Planner</code>","text":"<p>A base class for pathfinding algorithms. Serves as a template for implementing specific pathfinding strategies like A*, Dijkstra, etc.</p> <p>Attributes:</p> Name Type Description <code>time_limit</code> <code>float</code> <p>Maximum runtime in seconds before aborting the search.</p> <code>max_runs</code> <code>Union[int, float]</code> <p>Maximum iterations before aborting the search.</p> <code>weighted</code> <code>bool</code> <p>Indicates whether the algorithm supports weighted nodes.</p> <code>diagonal_movement</code> <code>int</code> <p>Enum specifying if diagonal movement is allowed.</p> <code>weight</code> <code>int</code> <p>Weight for the edges in the pathfinding algorithm.</p> <code>heuristic</code> <code>Optional[Callable]</code> <p>Function to calculate heuristic distance between two nodes.</p> <code>start_time</code> <code>float</code> <p>Tracks the start time of the algorithm.</p> <code>runs</code> <code>int</code> <p>Counter for the number of iterations.</p> Source code in <code>mplanner/core/planner.py</code> <pre><code>class Planner:\n    \"\"\"\n    A base class for pathfinding algorithms. Serves as a template for implementing\n    specific pathfinding strategies like A*, Dijkstra, etc.\n\n    Attributes:\n        time_limit (float): Maximum runtime in seconds before aborting the search.\n        max_runs (Union[int, float]): Maximum iterations before aborting the search.\n        weighted (bool): Indicates whether the algorithm supports weighted nodes.\n        diagonal_movement (int): Enum specifying if diagonal movement is allowed.\n        weight (int): Weight for the edges in the pathfinding algorithm.\n        heuristic (Optional[Callable]): Function to calculate heuristic distance between two nodes.\n        start_time (float): Tracks the start time of the algorithm.\n        runs (int): Counter for the number of iterations.\n    \"\"\"\n\n    def __init__(\n        self,\n        heuristic: Optional[Callable] = None,\n        weight: int = 1,\n        diagonal_movement: int = DMove.NEVER,\n        weighted: bool = True,\n        time_limit: float = TIME_LIMIT,\n        max_runs: Union[int, float] = MAX_RUNS,\n    ):\n        self.time_limit = time_limit\n        self.max_runs = max_runs\n        self.weighted = weighted\n        self.diagonal_movement = diagonal_movement\n        self.weight = weight\n        self.heuristic = heuristic\n\n        self.start_time: float = 0.0  # Track the start time of the algorithm\n        self.runs: int = 0  # Counter for the number of iterations\n\n    def distance_heuristic(\n        self, node_a: GridNode, node_b: GridNode, heuristic: Optional[Callable] = None\n    ) -&gt; float:\n        \"\"\"\n        Calculates the heuristic distance between two nodes.\n\n        Args:\n            node_a (GridNode): The first node.\n            node_b (GridNode): The second node.\n            heuristic (Optional[Callable]): Custom heuristic function. Defaults to None.\n\n        Returns:\n            float: Heuristic value representing the estimated cost.\n        \"\"\"\n        if not heuristic:\n            heuristic = self.heuristic\n        return heuristic(\n            abs(node_a.x - node_b.x),\n            abs(node_a.y - node_b.y),\n            abs(node_a.z - node_b.z),\n        )\n\n    def get_neighboring_nodes(\n        self, grid: Grid, current_node: GridNode, diagonal_movement: Optional[int] = None\n    ) -&gt; List[GridNode]:\n        \"\"\"\n       Identifies the neighbors of a node on the grid.\n\n        Args:\n            grid (Grid): The grid containing the nodes.\n            current_node (GridNode): The node whose neighbors are being searched.\n            diagonal_movement (Optional[int]): Specifies if diagonal movement is allowed. Defaults to None.\n\n        Returns:\n            List[GridNode]: List of neighboring nodes.\n        \"\"\"\n        if diagonal_movement is None:\n            diagonal_movement = self.diagonal_movement\n        return grid.neighbors(current_node, diagonal_movement=diagonal_movement)\n\n    def keep_running(self):\n        if self.runs &gt;= self.max_runs:\n            raise Exception(\n                f\"{self.__class__.__name__} exceeded {self.max_runs} iterations without finding the destination.\"\n            )\n\n        if time.time() - self.start_time &gt;= self.time_limit:\n            raise Exception(\n                f\"{self.__class__.__name__} exceeded the time limit of {self.time_limit} seconds, aborting!\"\n            )\n\n    def process_node(\n        self,\n        grid: Grid,\n        neighbor_node: GridNode,\n        parent_node: GridNode,\n        target_node: GridNode,\n        open_list: List,\n        open_value: int = 1,\n    ):\n        \"\"\"\n        Evaluates a node to determine if it should be added to the open list.\n\n        Args:\n            grid (Grid): The grid containing the nodes.\n            neighbor_node (GridNode): The neighbor node being evaluated.\n            parent_node (GridNode): The current node processing the neighbor.\n            target_node (GridNode): The target node (goal) in the pathfinding process.\n            open_list (List): The list of nodes to be processed next.\n            open_value (int): Value to mark the node as opened. Defaults to 1.\n        \"\"\"\n        # Calculate the cost to move from the parent node to the neighbor node\n        cost_to_neighbor = parent_node.g + grid.calc_cost(parent_node, neighbor_node, self.weighted)\n\n        if not neighbor_node.opened or cost_to_neighbor &lt; neighbor_node.g:\n            # Update node values if it is not opened or a shorter path is found\n            previous_cost = neighbor_node.f\n            neighbor_node.g = cost_to_neighbor\n            neighbor_node.h = neighbor_node.h or self.distance_heuristic(neighbor_node, target_node)\n            neighbor_node.f = neighbor_node.g + neighbor_node.h\n            neighbor_node.parent = parent_node\n\n            if not neighbor_node.opened:\n                open_list.push_node(neighbor_node)\n                neighbor_node.opened = open_value\n            else:\n                # Update node's position in the open list if the cost has been improved\n                open_list.remove_node(neighbor_node, previous_cost)\n                open_list.push_node(neighbor_node)\n\n    def evaluate_neighbors(\n        self,\n        start_node: GridNode,\n        target_node: GridNode,\n        grid: Grid,\n        open_list: List,\n        open_value: int = 1,\n        backtrace_by=None,\n    ) -&gt; Optional[List[GridNode]]:\n        \"\"\"\n        Evaluates the neighbors of the current node and determines the next step.\n\n        Args:\n            start_node (GridNode): The start node of the search.\n            target_node (GridNode): The goal node of the search.\n            grid (Grid): The grid containing the nodes.\n            open_list (List): The list of nodes to be processed next.\n            open_value (int): Value to mark the node as opened. Defaults to 1.\n            backtrace_by (optional): Custom backtrace method. Defaults to None.\n\n        Returns:\n            Optional[List[GridNode]]: The path if the target node is reached, otherwise None.\n        \"\"\"\n\n        raise NotImplementedError(\"Please implement evaluate_neighbors in your planner subclass\")\n\n    def get_planned_path(self, start_node: GridNode, target_node: GridNode, grid: Grid) -&gt; Tuple[List, int]:\n        \"\"\"\n        Finds the shortest path between two nodes on a grid.\n\n        Args:\n            start_node (GridNode): The starting node.\n            target_node (GridNode): The goal node.\n            grid (Grid): The grid containing the nodes.\n\n        Returns:\n            Tuple[List, int]: A tuple containing the path as a list of nodes and the number of iterations performed.\n        \"\"\"\n        self.start_time = time.time()  \n        self.runs = 0 \n        start_node.opened = True\n\n        open_list = PriorityQueueStructure(start_node, grid)\n\n        while len(open_list) &gt; 0:\n            self.runs += 1\n            self.keep_running()\n\n            path = self.evaluate_neighbors(start_node, target_node, grid, open_list)\n            if path:\n                return path, self.runs\n\n        # Return empty path if no solution is found\n        return [], self.runs\n\n    def __repr__(self):\n        return f\"&lt;{self.__class__.__name__}(diagonal_movement={self.diagonal_movement})&gt;\"\n</code></pre>"},{"location":"reference/core/planner/#mplanner.core.planner.Planner.distance_heuristic","title":"<code>distance_heuristic(node_a, node_b, heuristic=None)</code>","text":"<p>Calculates the heuristic distance between two nodes.</p> <p>Parameters:</p> Name Type Description Default <code>node_a</code> <code>GridNode</code> <p>The first node.</p> required <code>node_b</code> <code>GridNode</code> <p>The second node.</p> required <code>heuristic</code> <code>Optional[Callable]</code> <p>Custom heuristic function. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Heuristic value representing the estimated cost.</p> Source code in <code>mplanner/core/planner.py</code> <pre><code>def distance_heuristic(\n    self, node_a: GridNode, node_b: GridNode, heuristic: Optional[Callable] = None\n) -&gt; float:\n    \"\"\"\n    Calculates the heuristic distance between two nodes.\n\n    Args:\n        node_a (GridNode): The first node.\n        node_b (GridNode): The second node.\n        heuristic (Optional[Callable]): Custom heuristic function. Defaults to None.\n\n    Returns:\n        float: Heuristic value representing the estimated cost.\n    \"\"\"\n    if not heuristic:\n        heuristic = self.heuristic\n    return heuristic(\n        abs(node_a.x - node_b.x),\n        abs(node_a.y - node_b.y),\n        abs(node_a.z - node_b.z),\n    )\n</code></pre>"},{"location":"reference/core/planner/#mplanner.core.planner.Planner.evaluate_neighbors","title":"<code>evaluate_neighbors(start_node, target_node, grid, open_list, open_value=1, backtrace_by=None)</code>","text":"<p>Evaluates the neighbors of the current node and determines the next step.</p> <p>Parameters:</p> Name Type Description Default <code>start_node</code> <code>GridNode</code> <p>The start node of the search.</p> required <code>target_node</code> <code>GridNode</code> <p>The goal node of the search.</p> required <code>grid</code> <code>Grid</code> <p>The grid containing the nodes.</p> required <code>open_list</code> <code>List</code> <p>The list of nodes to be processed next.</p> required <code>open_value</code> <code>int</code> <p>Value to mark the node as opened. Defaults to 1.</p> <code>1</code> <code>backtrace_by</code> <code>optional</code> <p>Custom backtrace method. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[List[GridNode]]</code> <p>Optional[List[GridNode]]: The path if the target node is reached, otherwise None.</p> Source code in <code>mplanner/core/planner.py</code> <pre><code>def evaluate_neighbors(\n    self,\n    start_node: GridNode,\n    target_node: GridNode,\n    grid: Grid,\n    open_list: List,\n    open_value: int = 1,\n    backtrace_by=None,\n) -&gt; Optional[List[GridNode]]:\n    \"\"\"\n    Evaluates the neighbors of the current node and determines the next step.\n\n    Args:\n        start_node (GridNode): The start node of the search.\n        target_node (GridNode): The goal node of the search.\n        grid (Grid): The grid containing the nodes.\n        open_list (List): The list of nodes to be processed next.\n        open_value (int): Value to mark the node as opened. Defaults to 1.\n        backtrace_by (optional): Custom backtrace method. Defaults to None.\n\n    Returns:\n        Optional[List[GridNode]]: The path if the target node is reached, otherwise None.\n    \"\"\"\n\n    raise NotImplementedError(\"Please implement evaluate_neighbors in your planner subclass\")\n</code></pre>"},{"location":"reference/core/planner/#mplanner.core.planner.Planner.get_neighboring_nodes","title":"<code>get_neighboring_nodes(grid, current_node, diagonal_movement=None)</code>","text":"<p>Identifies the neighbors of a node on the grid.</p> <p>Args:      grid (Grid): The grid containing the nodes.      current_node (GridNode): The node whose neighbors are being searched.      diagonal_movement (Optional[int]): Specifies if diagonal movement is allowed. Defaults to None.</p> <p>Returns:      List[GridNode]: List of neighboring nodes.</p> Source code in <code>mplanner/core/planner.py</code> <pre><code>def get_neighboring_nodes(\n    self, grid: Grid, current_node: GridNode, diagonal_movement: Optional[int] = None\n) -&gt; List[GridNode]:\n    \"\"\"\n   Identifies the neighbors of a node on the grid.\n\n    Args:\n        grid (Grid): The grid containing the nodes.\n        current_node (GridNode): The node whose neighbors are being searched.\n        diagonal_movement (Optional[int]): Specifies if diagonal movement is allowed. Defaults to None.\n\n    Returns:\n        List[GridNode]: List of neighboring nodes.\n    \"\"\"\n    if diagonal_movement is None:\n        diagonal_movement = self.diagonal_movement\n    return grid.neighbors(current_node, diagonal_movement=diagonal_movement)\n</code></pre>"},{"location":"reference/core/planner/#mplanner.core.planner.Planner.get_planned_path","title":"<code>get_planned_path(start_node, target_node, grid)</code>","text":"<p>Finds the shortest path between two nodes on a grid.</p> <p>Parameters:</p> Name Type Description Default <code>start_node</code> <code>GridNode</code> <p>The starting node.</p> required <code>target_node</code> <code>GridNode</code> <p>The goal node.</p> required <code>grid</code> <code>Grid</code> <p>The grid containing the nodes.</p> required <p>Returns:</p> Type Description <code>Tuple[List, int]</code> <p>Tuple[List, int]: A tuple containing the path as a list of nodes and the number of iterations performed.</p> Source code in <code>mplanner/core/planner.py</code> <pre><code>def get_planned_path(self, start_node: GridNode, target_node: GridNode, grid: Grid) -&gt; Tuple[List, int]:\n    \"\"\"\n    Finds the shortest path between two nodes on a grid.\n\n    Args:\n        start_node (GridNode): The starting node.\n        target_node (GridNode): The goal node.\n        grid (Grid): The grid containing the nodes.\n\n    Returns:\n        Tuple[List, int]: A tuple containing the path as a list of nodes and the number of iterations performed.\n    \"\"\"\n    self.start_time = time.time()  \n    self.runs = 0 \n    start_node.opened = True\n\n    open_list = PriorityQueueStructure(start_node, grid)\n\n    while len(open_list) &gt; 0:\n        self.runs += 1\n        self.keep_running()\n\n        path = self.evaluate_neighbors(start_node, target_node, grid, open_list)\n        if path:\n            return path, self.runs\n\n    # Return empty path if no solution is found\n    return [], self.runs\n</code></pre>"},{"location":"reference/core/planner/#mplanner.core.planner.Planner.process_node","title":"<code>process_node(grid, neighbor_node, parent_node, target_node, open_list, open_value=1)</code>","text":"<p>Evaluates a node to determine if it should be added to the open list.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>Grid</code> <p>The grid containing the nodes.</p> required <code>neighbor_node</code> <code>GridNode</code> <p>The neighbor node being evaluated.</p> required <code>parent_node</code> <code>GridNode</code> <p>The current node processing the neighbor.</p> required <code>target_node</code> <code>GridNode</code> <p>The target node (goal) in the pathfinding process.</p> required <code>open_list</code> <code>List</code> <p>The list of nodes to be processed next.</p> required <code>open_value</code> <code>int</code> <p>Value to mark the node as opened. Defaults to 1.</p> <code>1</code> Source code in <code>mplanner/core/planner.py</code> <pre><code>def process_node(\n    self,\n    grid: Grid,\n    neighbor_node: GridNode,\n    parent_node: GridNode,\n    target_node: GridNode,\n    open_list: List,\n    open_value: int = 1,\n):\n    \"\"\"\n    Evaluates a node to determine if it should be added to the open list.\n\n    Args:\n        grid (Grid): The grid containing the nodes.\n        neighbor_node (GridNode): The neighbor node being evaluated.\n        parent_node (GridNode): The current node processing the neighbor.\n        target_node (GridNode): The target node (goal) in the pathfinding process.\n        open_list (List): The list of nodes to be processed next.\n        open_value (int): Value to mark the node as opened. Defaults to 1.\n    \"\"\"\n    # Calculate the cost to move from the parent node to the neighbor node\n    cost_to_neighbor = parent_node.g + grid.calc_cost(parent_node, neighbor_node, self.weighted)\n\n    if not neighbor_node.opened or cost_to_neighbor &lt; neighbor_node.g:\n        # Update node values if it is not opened or a shorter path is found\n        previous_cost = neighbor_node.f\n        neighbor_node.g = cost_to_neighbor\n        neighbor_node.h = neighbor_node.h or self.distance_heuristic(neighbor_node, target_node)\n        neighbor_node.f = neighbor_node.g + neighbor_node.h\n        neighbor_node.parent = parent_node\n\n        if not neighbor_node.opened:\n            open_list.push_node(neighbor_node)\n            neighbor_node.opened = open_value\n        else:\n            # Update node's position in the open list if the cost has been improved\n            open_list.remove_node(neighbor_node, previous_cost)\n            open_list.push_node(neighbor_node)\n</code></pre>"},{"location":"reference/core/priority_queue/","title":"priority_queue","text":""},{"location":"reference/core/priority_queue/#mplanner.core.priority_queue.PriorityQueueStructure","title":"<code>PriorityQueueStructure</code>","text":"<p>A priority queue data structure optimized for pathfinding algorithms.</p> <p>Manages an open list of nodes, allows efficient retrieval of the lowest-cost node, and supports marking nodes as removed for handling updates during pathfinding.</p> <p>Attributes:</p> Name Type Description <code>grid</code> <code>Union[Grid, World]</code> <p>The grid or world containing the nodes.</p> <code>open_list</code> <code>list</code> <p>The priority queue containing nodes as tuples.</p> <code>removed_node_tuples</code> <code>set</code> <p>Tracks nodes that are logically removed but not yet physically removed.</p> <code>priority</code> <code>queue_order (dict</code> <p>Maps node identifiers to their priority queue order for tie-breaking.</p> <code>number_pushed</code> <code>int</code> <p>Counter to maintain priority queue stability during tie-breaking.</p> Source code in <code>mplanner/core/priority_queue.py</code> <pre><code>class PriorityQueueStructure:\n    \"\"\"\n    A priority queue data structure optimized for pathfinding algorithms.\n\n    Manages an open list of nodes, allows efficient retrieval of the lowest-cost node,\n    and supports marking nodes as removed for handling updates during pathfinding.\n\n    Attributes:\n        grid (Union[Grid, World]): The grid or world containing the nodes.\n        open_list (list): The priority queue containing nodes as tuples.\n        removed_node_tuples (set): Tracks nodes that are logically removed but not yet physically removed.\n        priority queue_order (dict): Maps node identifiers to their priority queue order for tie-breaking.\n        number_pushed (int): Counter to maintain priority queue stability during tie-breaking.\n    \"\"\"\n\n    def __init__(self, node: GridNode, grid: Union[Grid, World]):\n        self.grid = grid\n        self._get_node_tuple = self._determine_node_retrieval_function()\n        self._get_node = self._determine_node_function()\n        self.open_list = [self._get_node_tuple(node, 0)]  # PriorityQueue of nodes (priority queue)\n        self.removed_node_tuples = set()  # Tracks logically removed nodes\n        self.priority_queue_order = {}  # Tracks the order nodes are added (for tie-breaking)\n        self.number_pushed = 0  # Counter for tie-breaking stability\n\n    def _determine_node_retrieval_function(self) -&gt; Callable:\n        \"\"\"\n        Determines the function to create tuples for nodes based on the grid type.\n\n        Returns:\n            Callable: A function generating tuples for use in the priority queue.\n\n        Raises:\n            ValueError: If the grid type is unsupported.\n        \"\"\"\n        if isinstance(self.grid, Grid):\n            return lambda node, priority_queue_order: (node.f, priority_queue_order, *node.identifier)\n\n        if isinstance(self.grid, World):\n            return lambda node, priority_queue_order: (node.f, priority_queue_order, *node.identifier)\n\n        raise ValueError(\"Unsupported grid type\")\n\n    def _determine_node_function(self) -&gt; Callable:\n        \"\"\"\n        Determines the function to retrieve a `GridNode` from its tuple representation.\n\n        Returns:\n            Callable: A function retrieving a `GridNode` from its tuple.\n\n        Raises:\n            ValueError: If the grid type is unsupported.\n        \"\"\"\n        if isinstance(self.grid, Grid):\n            return lambda node_tuple: self.grid.node(*node_tuple[2:])\n\n        if isinstance(self.grid, World):\n            return lambda node_tuple: self.grid.grids[node_tuple[5]].node(*node_tuple[2:5])\n\n        raise ValueError(\"Unsupported grid type\")\n\n    def pop_node(self) -&gt; GridNode:\n        \"\"\"\n        Removes and returns the node with the lowest cost (`f`) from the priority queue.\n\n        Skips nodes that have been logically removed.\n\n        Returns:\n            GridNode: The node with the lowest cost in the priority queue.\n        \"\"\"\n        node_tuple = heapq.heappop(self.open_list)\n        while node_tuple in self.removed_node_tuples:\n            node_tuple = heapq.heappop(self.open_list)\n\n        return self._get_node(node_tuple)\n\n    def push_node(self, node: GridNode):\n        \"\"\"\n        Adds a node to the priority queue.\n\n        Args:\n            node (GridNode): The node to add. Must have an `f` attribute for cost evaluation.\n        \"\"\"\n        self.number_pushed += 1  # Increment counter for tie-breaking\n        node_tuple = self._get_node_tuple(node, self.number_pushed)\n\n        self.priority_queue_order[node.identifier] = self.number_pushed  # Track the order of insertion\n        heapq.heappush(self.open_list, node_tuple)  # Add node to the priority_queue\n\n    def remove_node(self, node: GridNode, old_f: float):\n        \"\"\"\n        Marks a node as removed from the priority_queue.\n\n        This logical removal prevents the node from being returned when popped.\n        This approach is efficient for handling updates during pathfinding.\n\n        Args:\n            node (GridNode): The node to mark as removed.\n            old_f (float): The previous cost of the node, used to identify it in the priority_queue.\n        \"\"\"\n        priority_queue_order = self.priority_queue_order[node.identifier]\n        node_tuple = self._get_node_tuple(node, priority_queue_order)\n        self.removed_node_tuples.add(node_tuple)\n\n    def __len__(self) -&gt; int:\n        return len(self.open_list)\n</code></pre>"},{"location":"reference/core/priority_queue/#mplanner.core.priority_queue.PriorityQueueStructure.pop_node","title":"<code>pop_node()</code>","text":"<p>Removes and returns the node with the lowest cost (<code>f</code>) from the priority queue.</p> <p>Skips nodes that have been logically removed.</p> <p>Returns:</p> Name Type Description <code>GridNode</code> <code>GridNode</code> <p>The node with the lowest cost in the priority queue.</p> Source code in <code>mplanner/core/priority_queue.py</code> <pre><code>def pop_node(self) -&gt; GridNode:\n    \"\"\"\n    Removes and returns the node with the lowest cost (`f`) from the priority queue.\n\n    Skips nodes that have been logically removed.\n\n    Returns:\n        GridNode: The node with the lowest cost in the priority queue.\n    \"\"\"\n    node_tuple = heapq.heappop(self.open_list)\n    while node_tuple in self.removed_node_tuples:\n        node_tuple = heapq.heappop(self.open_list)\n\n    return self._get_node(node_tuple)\n</code></pre>"},{"location":"reference/core/priority_queue/#mplanner.core.priority_queue.PriorityQueueStructure.push_node","title":"<code>push_node(node)</code>","text":"<p>Adds a node to the priority queue.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>GridNode</code> <p>The node to add. Must have an <code>f</code> attribute for cost evaluation.</p> required Source code in <code>mplanner/core/priority_queue.py</code> <pre><code>def push_node(self, node: GridNode):\n    \"\"\"\n    Adds a node to the priority queue.\n\n    Args:\n        node (GridNode): The node to add. Must have an `f` attribute for cost evaluation.\n    \"\"\"\n    self.number_pushed += 1  # Increment counter for tie-breaking\n    node_tuple = self._get_node_tuple(node, self.number_pushed)\n\n    self.priority_queue_order[node.identifier] = self.number_pushed  # Track the order of insertion\n    heapq.heappush(self.open_list, node_tuple)  # Add node to the priority_queue\n</code></pre>"},{"location":"reference/core/priority_queue/#mplanner.core.priority_queue.PriorityQueueStructure.remove_node","title":"<code>remove_node(node, old_f)</code>","text":"<p>Marks a node as removed from the priority_queue.</p> <p>This logical removal prevents the node from being returned when popped. This approach is efficient for handling updates during pathfinding.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>GridNode</code> <p>The node to mark as removed.</p> required <code>old_f</code> <code>float</code> <p>The previous cost of the node, used to identify it in the priority_queue.</p> required Source code in <code>mplanner/core/priority_queue.py</code> <pre><code>def remove_node(self, node: GridNode, old_f: float):\n    \"\"\"\n    Marks a node as removed from the priority_queue.\n\n    This logical removal prevents the node from being returned when popped.\n    This approach is efficient for handling updates during pathfinding.\n\n    Args:\n        node (GridNode): The node to mark as removed.\n        old_f (float): The previous cost of the node, used to identify it in the priority_queue.\n    \"\"\"\n    priority_queue_order = self.priority_queue_order[node.identifier]\n    node_tuple = self._get_node_tuple(node, priority_queue_order)\n    self.removed_node_tuples.add(node_tuple)\n</code></pre>"},{"location":"reference/core/utils/","title":"utils","text":""},{"location":"reference/core/utils/#mplanner.core.utils.add_offset_to_tuple","title":"<code>add_offset_to_tuple(input_tuple, offset)</code>","text":"<p>Adds an offset to each element of a tuple.</p> <p>Parameters:</p> Name Type Description Default <code>input_tuple</code> <code>Tuple[int, ...]</code> <p>A tuple of integers.</p> required <code>offset</code> <code>Union[int, float]</code> <p>The value to be added to each element in the tuple.</p> required <p>Returns:</p> Type Description <code>Tuple[int, ...]</code> <p>Tuple[int, ...]: A new tuple with the offset added to each element.</p> Source code in <code>mplanner/core/utils.py</code> <pre><code>def add_offset_to_tuple(input_tuple: Tuple[int, ...], offset: Union[int, float]) -&gt; Tuple[int, ...]:\n    \"\"\"\n    Adds an offset to each element of a tuple.\n\n    Args:\n        input_tuple (Tuple[int, ...]): A tuple of integers.\n        offset (Union[int, float]): The value to be added to each element in the tuple.\n\n    Returns:\n        Tuple[int, ...]: A new tuple with the offset added to each element.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        raise ValueError(\"Input must be a tuple.\")\n    if not isinstance(offset, (int, float)):\n        raise ValueError(\"Offset must be an integer or float.\")\n\n    return tuple(int(element + offset) for element in input_tuple)\n</code></pre>"},{"location":"reference/core/utils/#mplanner.core.utils.backtrack","title":"<code>backtrack(node)</code>","text":"<p>Generate a path by backtracking from the given node to its root (start) node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>GridNode</code> <p>The node from which to start backtracking.</p> required <p>Returns:</p> Type Description <code>List[GridNode]</code> <p>List[GridNode]: A list of nodes representing the path, ordered from start to the given node.</p> Source code in <code>mplanner/core/utils.py</code> <pre><code>def backtrack(node: GridNode) -&gt; List[GridNode]:\n    \"\"\"\n    Generate a path by backtracking from the given node to its root (start) node.\n\n    Args:\n        node (GridNode): The node from which to start backtracking.\n\n    Returns:\n        List[GridNode]: A list of nodes representing the path, ordered from start to the given node.\n    \"\"\"\n    path = [node]\n    while node.parent:\n        node = node.parent\n        path.append(node)\n    path.reverse()  # Ensure the path is ordered from start to end\n    return path\n</code></pre>"},{"location":"reference/core/utils/#mplanner.core.utils.bidirectional_backtrack","title":"<code>bidirectional_backtrack(node_a, node_b)</code>","text":"<p>Generate a complete path for bi-directional A* by backtracking from both start and end nodes.</p> <p>Parameters:</p> Name Type Description Default <code>node_a</code> <code>GridNode</code> <p>The node from which to backtrack to reconstruct the path from the start.</p> required <code>node_b</code> <code>GridNode</code> <p>The node from which to backtrack to reconstruct the path to the end.</p> required <p>Returns:</p> Type Description <code>List[GridNode]</code> <p>List[GridNode]: A combined path from the start node to the end node, passing through the meeting point.</p> Source code in <code>mplanner/core/utils.py</code> <pre><code>def bidirectional_backtrack(node_a: GridNode, node_b: GridNode) -&gt; List[GridNode]:\n    \"\"\"\n    Generate a complete path for bi-directional A* by backtracking from both start and end nodes.\n\n    Args:\n        node_a (GridNode): The node from which to backtrack to reconstruct the path from the start.\n        node_b (GridNode): The node from which to backtrack to reconstruct the path to the end.\n\n    Returns:\n        List[GridNode]: A combined path from the start node to the end node, passing through the meeting point.\n    \"\"\"\n    path_a = backtrack(node_a)  # Path from start to meeting point\n    path_b = backtrack(node_b)  # Path from end to meeting point\n    path_b.reverse()  # Reverse the second path to ensure correct order\n    return path_a + path_b  # Combine the two paths into one\n</code></pre>"},{"location":"reference/core/utils/#mplanner.core.utils.calculate_grid_size","title":"<code>calculate_grid_size(bounds, resolution)</code>","text":"<p>Calculates the grid size based on environment bounds and resolution.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>dict</code> <p>Dictionary containing the 'min' and 'max' bounds of the environment in (x, y, z).</p> required <code>resolution</code> <code>float</code> <p>Size of each grid cell.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Grid dimensions (width, height, depth).</p> Source code in <code>mplanner/core/utils.py</code> <pre><code>def calculate_grid_size(bounds: Dict, resolution: float) -&gt; Tuple:\n    \"\"\"\n    Calculates the grid size based on environment bounds and resolution.\n\n    Args:\n        bounds (dict): Dictionary containing the 'min' and 'max' bounds of the environment in (x, y, z).\n        resolution (float): Size of each grid cell.\n\n    Returns:\n        tuple: Grid dimensions (width, height, depth).\n    \"\"\"\n    grid_size = tuple(\n        math.ceil((bounds[\"max\"][i] - bounds[\"min\"][i]) / resolution) for i in range(3)\n    )\n    return grid_size\n</code></pre>"},{"location":"reference/core/utils/#mplanner.core.utils.mark_obstacles","title":"<code>mark_obstacles(matrix, position, dimensions, resolution, origin)</code>","text":"<p>Marks a cuboidal obstacle in the grid matrix.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>ndarray</code> <p>The grid matrix.</p> required <code>position</code> <code>tuple</code> <p>Decimal (X, Y, Z) center of the obstacle.</p> required <code>dimensions</code> <code>tuple</code> <p>Dimensions (X, Y, Z) of the obstacle.</p> required <code>resolution</code> <code>float</code> <p>Size of each grid cell.</p> required <code>origin</code> <code>tuple</code> <p>Origin (X, Y, Z) of the grid.</p> required Source code in <code>mplanner/core/utils.py</code> <pre><code>def mark_obstacles(matrix: np.ndarray, position: Tuple, dimensions: Tuple, resolution: float, origin: Tuple):\n    \"\"\"\n    Marks a cuboidal obstacle in the grid matrix.\n\n    Args:\n        matrix (numpy.ndarray): The grid matrix.\n        position (tuple): Decimal (X, Y, Z) center of the obstacle.\n        dimensions (tuple): Dimensions (X, Y, Z) of the obstacle.\n        resolution (float): Size of each grid cell.\n        origin (tuple): Origin (X, Y, Z) of the grid.\n    \"\"\"\n    min_coords = [\n        int((position[i] - dimensions[i] / 2 - origin[i]) / resolution) for i in range(3)\n    ]\n    max_coords = [\n        int((position[i] + dimensions[i] / 2 - origin[i]) / resolution) for i in range(3)\n    ]\n    for x in range(max(0, min_coords[0]), min(matrix.shape[0], max_coords[0] + 1)):\n        for y in range(max(0, min_coords[1]), min(matrix.shape[1], max_coords[1] + 1)):\n            for z in range(max(0, min_coords[2]), min(matrix.shape[2], max_coords[2] + 1)):\n                matrix[x, y, z] = 0  # Mark as obstacle\n</code></pre>"},{"location":"reference/core/utils/#mplanner.core.utils.to_grid_coords","title":"<code>to_grid_coords(position, resolution, origin)</code>","text":"<p>Converts a position in decimal coordinates to grid indices.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>tuple</code> <p>Decimal (X, Y, Z) coordinates.</p> required <code>resolution</code> <code>float</code> <p>Size of each grid cell.</p> required <code>origin</code> <code>tuple</code> <p>Origin (X, Y, Z) of the grid.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Grid indices (x, y, z).</p> Source code in <code>mplanner/core/utils.py</code> <pre><code>def to_grid_coords(position: Tuple, resolution: float, origin: Tuple) -&gt; Tuple:\n    \"\"\"\n    Converts a position in decimal coordinates to grid indices.\n\n    Args:\n        position (tuple): Decimal (X, Y, Z) coordinates.\n        resolution (float): Size of each grid cell.\n        origin (tuple): Origin (X, Y, Z) of the grid.\n\n    Returns:\n        tuple: Grid indices (x, y, z).\n    \"\"\"\n    return tuple(int(round((p - o) / resolution)) for p, o in zip(position, origin))\n</code></pre>"},{"location":"reference/core/utils/#mplanner.core.utils.tuple_ceil","title":"<code>tuple_ceil(input_tuple)</code>","text":"<p>Takes a tuple of numbers and returns a tuple with the ceiling of each element.</p> <p>Parameters:</p> Name Type Description Default <code>input_tuple</code> <code>Tuple[float, ...]</code> <p>A tuple of numbers (floats).</p> required <p>Returns:</p> Type Description <code>Tuple[int, ...]</code> <p>Tuple[int, ...]: A tuple with the ceiling values of each number in the input.</p> Source code in <code>mplanner/core/utils.py</code> <pre><code>def tuple_ceil(input_tuple: Tuple[float, ...]) -&gt; Tuple[int, ...]:\n    \"\"\"\n    Takes a tuple of numbers and returns a tuple with the ceiling of each element.\n\n    Args:\n        input_tuple (Tuple[float, ...]): A tuple of numbers (floats).\n\n    Returns:\n        Tuple[int, ...]: A tuple with the ceiling values of each number in the input.\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        raise ValueError(\"Input must be a tuple.\")\n\n    return tuple(math.ceil(element) for element in input_tuple)\n</code></pre>"}]}